<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dp on 隨寫日誌</title><link>https://snow-ham1949.github.io/tags/dp/</link><description>Recent content in Dp on 隨寫日誌</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>Erin Li</copyright><lastBuildDate>Mon, 24 Oct 2022 21:57:08 +0000</lastBuildDate><atom:link href="https://snow-ham1949.github.io/tags/dp/index.xml" rel="self" type="application/rss+xml"/><item><title>Codeforces 1635D. Infinite Set</title><link>https://snow-ham1949.github.io/posts/codeforces-1635d-infinite-set/</link><pubDate>Mon, 24 Oct 2022 21:57:08 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/codeforces-1635d-infinite-set/</guid><description>這題好難，我看了好多遍別人的題解才懂 QwQ
題目 給一個陣列，考慮一個無限的集合 $S$ 由符合以下條件之一的 $x$ 構成
$x = a[i]$ $x = 2 * y + 1$ and $y \in S$ $x = 4 * y$ and $y \in S$ 問在集合 $S$ 中有多少元素小於 $2^p$，答案很大要 mod $1e9+7$
作法 因為 $p$ 的範圍會到 2e5，所以要用二進制來想這題。
對於一個二進位制為 $t$ 的數字，可以想像操作二就是左移一位然後末位補 1，操作二就是左移兩位（這邊就有點像 string）。所以可以觀察出一個結論，就是對於一個數字，把它增加 $i$ 位的方法有 $dp_i$ 種，這裡的 $dp$ 就是費波那契數列。
那這跟答案有什麼關係呢，假設一個二進位制為 $t$ 的數字存在在 $a$ 之中，那麼他擴展出的數字要小於 $p$ 的話，他擴展出的數字的數量就會是 $\sum_{i = 0}^{p - t} dp_i$，也就是不擴展、擴展一位、擴展兩位&amp;hellip;，那這件事情可以透過在算費波那契數列的時候算前綴和得到。
接下來考慮是不是每個 $a[i]$ 都會對答案有貢獻，其實不是這樣，因為 $S$ 是一個 set，不會有重複的數字出現，所以如果會重複出現就不用算。那題解的做法是說那就把會產生的數字想成一棵樹，我一直去看產生 $x$ 的 parent 有沒有已經被 create 過，如果有的話，那就代表 $x$ 已經被前面的數字（也就是 parent） create 過了，那就不能算進答案裡面（因為已經算過了），在這邊的話 parent 的意思就是說看他能不能逆推操作二或操作三。</description></item><item><title>CSES Tree Matching</title><link>https://snow-ham1949.github.io/posts/cses-tree-matching/</link><pubDate>Mon, 19 Sep 2022 21:51:48 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/cses-tree-matching/</guid><description>第一次接觸樹 dp OuO
題目 給一棵樹，找到最大的邊集合使得任兩邊不共享一個點，輸出集合大小。
作法 定義 如果是 array 版本的話（i.e. 給一個序列不能選相鄰的，最大化價值），比較容易可以想到轉移式 $dp(i) = max(v_i + dp(i - 2), dp(i - 1))$
轉成樹的版本的話，就需要在樹上面做 dp，對於一個節點 $u$ 有下面兩種情況
取一條跟 $v \in child(u)$ 有連接的邊，答案定義為 $dp_0(u)$ 不取任何跟 $v \in child(u)$ 有連接的邊，答案定義為 $dp_1(u)$ 為什麼沒有取兩條以上的 case 呢？因為如果取兩條以上的話 $u$ 就會變成那個共享的點。
所以從上面的定義可以知道答案是 $max(dp_0(1), dp_1(1))$
轉移式 $dp_1(u)$
因為不取任何跟 $v \in child(u)$ 有連接的邊，所以不管「跟 $v$ 的小孩有連接的邊」取不取都可以，所以答案就是
$dp_1(u) = \sum_{v \in child(u)} max(dp_0(v), dp_1(v))$
$dp_0(u)$
可以先處理取一條的部分，因為取了 $u \rightarrow v$ 這一條，所以「不取任何跟 $w \in child(v)$ 有連接的邊」是 $dp_1(v)$，再加上 $u \rightarrow v$ 這一條，就是 $dp_1(v) + 1$。</description></item><item><title>Atcoder DP contest (持續更新中)</title><link>https://snow-ham1949.github.io/posts/atcoder-dp-contest/</link><pubDate>Sun, 28 Aug 2022 19:12:56 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/atcoder-dp-contest/</guid><description>紀錄一下自己練習 dp 的過程，最近在寫 icpc 培訓班的作業感受到自己的 dp 實在是太爛了&amp;hellip; 剛好被推薦有這個題單可以練習，所以就順便把自己不會的東西整理一下變成一篇文，希望可以加深一點印象w
btw 如果是我本來就會的東西就不會寫解釋純貼 code。
題單
A. Frog 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const int maxn = 1e5 + 5; int h[maxn], dp[maxn]; void solve() { int n; cin &amp;gt;&amp;gt; n; for (int i = 1; i &amp;lt;= n; i++) cin &amp;gt;&amp;gt; h[i]; dp[1] = 0, dp[2] = abs(h[2] - h[1]); for (int i = 3; i &amp;lt;= n; i++) { dp[i] = min(dp[i - 1] + abs(h[i] - h[i - 1]), dp[i - 2] + abs(h[i] - h[i - 2])); } cout &amp;lt;&amp;lt; dp[n] &amp;lt;&amp;lt; endl; } B.</description></item><item><title>Leetcode 629. K Inverse Pairs Array</title><link>https://snow-ham1949.github.io/posts/leetcode-629-k-inverse-pairs-array/</link><pubDate>Sun, 17 Jul 2022 21:27:49 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-629-k-inverse-pairs-array/</guid><description>題目 link
作法 $O(nk^2)$ 我以為會 TLE 然後剛剛測發現其實不會 QQ，可以定義 $dp[i][j]$ 是使用 1 ~ $i$ 的數字後，可以構成 $j$ 個 inversion pair 的數量，那答案就會是 $dp[n][k]$。
轉移式的話可以觀察，如果我現在已經放好 1~3 然後我要把 4 放進去這個序列裡面，我可以有下面這幾種放法
放法 造成的逆序數對 4xxx 3 x4xx 2 xx4x 1 xxx4 0 所以就可以發現這樣的轉移式
$dp[i][j] = dp[i - 1][j - k]$, $\forall k \in [0, i - 1]$
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int kInversePairs(int n, int k) { const int mod = 1e9 + 7; vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; dp(n + 1, vector&amp;lt;int&amp;gt;(k + 1, 1)); for (int i = 1; i &amp;lt;= n; i++) { for (int j = 0; j &amp;lt;= k; j++) { for (int k = 0; k &amp;lt;= min(K, N - 1); k++) { dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % mod; } } } return dp[n][k]; } }; $O(nk)$ 同樣的概念，只是剛剛的轉移式可以再優化</description></item><item><title>Leetcode 2305. Fair Distribution of Cookies</title><link>https://snow-ham1949.github.io/posts/leetcode-2305-fair-distribution-of-cookies/</link><pubDate>Thu, 14 Jul 2022 17:07:07 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-2305-fair-distribution-of-cookies/</guid><description>題目 link
作法 bit manipulation + dp 這題跟 這題 蠻像的，不過這次是要盡可能平均分然後輸出這樣分以後一個小孩最多可能拿到的餅乾數。
我一開始想跟 698 那題一樣做，不過這樣的話是沒辦法知道 max 的，因為只能用袋子分而不是直接拿餅乾分，所以要換一個方法。
定義 dp[i][mask] 為當人數有 $i$ 個的時候取的 subset 為 $mask$ 時，拿到最多餅乾的小孩的餅乾數量的最小值，就會有以下的轉移式
dp[i][mask] = min(dp[i][mask], max(dp[i - 1][mask ^ submask], sum[submask]))
意思是說在這群小孩裡面有個小孩拿了 submask 這樣的 subset，剩下的小孩拿其他的，看最大值會是多少，然後因為我最後要的是最小化最大值，所以取 min。
關於 enumerating submask of mask 可以看 這篇 講解
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: int distributeCookies(vector&amp;lt;int&amp;gt;&amp;amp; cookies, int k) { int n = cookies.</description></item><item><title>Leetcode 698. Partition to K Equal Sum Subsets</title><link>https://snow-ham1949.github.io/posts/leetcode-698-partition-to-k-equal-sum-subsets/</link><pubDate>Wed, 13 Jul 2022 18:17:01 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-698-partition-to-k-equal-sum-subsets/</guid><description>好像比較了解 bit manipulation 可以幹嘛了（？）
題目 link
做法 這題是 這題 的進化版（？），要分成 $k$ 堆，一樣可以用 bit + dp 做，然後這邊還有一個小技巧是直接用餘數，這樣就可以直接在最後判是不是等於 0，如果不用餘數的話可能就要寫個 if 或者用更複雜的方式去判現在這個 element 能不能被放進這個 subset
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: bool canPartitionKSubsets(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { int sum = 0; for (int num : nums) sum += num; if (sum % k) return false; int target = sum / k; int n = nums.</description></item><item><title>Leetcode 473. Matchsticks to Square</title><link>https://snow-ham1949.github.io/posts/leetcode-473-matchsticks-to-square/</link><pubDate>Tue, 12 Jul 2022 23:20:53 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-473-matchsticks-to-square/</guid><description>不會 dp 也不會 bit manipulation QAQ
題目 link
作法 dfs 一個最簡單的做法可以直接 recursion, code 如下
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: bool chk(vector&amp;lt;int&amp;gt;&amp;amp; side, vector&amp;lt;int&amp;gt;&amp;amp; matches, int id, int n) { if (id == n) { return side[0] == side[1] and side[1] == side[2] and side[2] == side[3]; } for (int i = 0; i &amp;lt; 4; i++) { side[i] += matches[id]; if (chk(side, matches, id + 1, n)) return true; side[i] -= matches[id]; } return false; } bool makesquare(vector&amp;lt;int&amp;gt;&amp;amp; matches) { int n = match.</description></item><item><title>Leetcode 1696. Jump Game VI</title><link>https://snow-ham1949.github.io/posts/leetcode-1696-jump-game-vi/</link><pubDate>Sun, 10 Jul 2022 00:19:10 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-1696-jump-game-vi/</guid><description>題目 link
作法 令 dp[i] 為以 $i$ 為起點到終點能獲得的最大分數。如果枚舉可以走的範圍內最大的話複雜度會是 $O(nk)$ 會 TLE，所以可以用 deque 或是 priority_queue 來優化，維護一個可以走的範圍內的單調隊列或者 heap，就可以在 $O(1)$ 或是 $O(logk)$ 內拿到最大值了。
下面兩種 code 分別用 deque 和 priority_queue 寫， deque 版本是從起點開始做，priority_queue 版本是從終點開始做
deque 版本
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int maxResult(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { int n = nums.size(); vector&amp;lt;int&amp;gt; dp(n, 0); deque&amp;lt;int&amp;gt; dq; dp[0] = nums[0]; dq.</description></item><item><title>Leetcode 32. Longest Valid Parentheses</title><link>https://snow-ham1949.github.io/posts/leetcode-32-longest-valid-parentheses/</link><pubDate>Thu, 07 Jul 2022 21:17:42 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-32-longest-valid-parentheses/</guid><description>我真的不會 dp QwQ
題目 link
作法 可以先從基礎題開始想，就是判合法括號字串，這個用 stack 就可以解決（其實這題也可，但我想練 dp），從這個的想法出發的話，可以先想到
如果前一個是 ( 後一個是 )，那就有一個長度為 2 的合法括號字串 如果以 dp[i] 來記錄以 $i 為結尾最長合法括號字串長度的話， 1. 可以寫成 dp[i] = dp[i - 1] + 2，要注意這個是建立在你已經知道前面有 ( 了。
接下來再考慮這個 case ()()，因為 dp[i] 要記錄的是以 $i$ 為結尾最長合法括號字串長度，所以前面合法括號字串長度也要算進來，這個的算法可以利用現在紀錄的長度跟 index 來算。
以這個 case 來說，它其實可以切成兩個 ()，在算第二個的時候按照上面的式子只會記錄到長度 2，，所以要去看 i - dp[i] 這個 index dp 值存的是多少然後加起來。
就有
if (i - dp[i] &amp;gt; 0) dp[i] += dp[i - dp[i]] 最後就是看整個字串然後一邊用 dp 值更新答案
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int longestValidParentheses(string s) { int n = s.</description></item><item><title>Leetcode 96. Unique Binary Search Trees</title><link>https://snow-ham1949.github.io/posts/leetcode-96-unique-binary-search-trees/</link><pubDate>Sat, 12 Feb 2022 19:13:27 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-96-unique-binary-search-trees/</guid><description>忘記數學了所以來複習一下 :p
題目 link
作法 如果假設有 $n$ 個節點的二元樹有 $G_n$ 個，其中以 $i$ 節點為根的數目有 $F_i$ 個，那麼
$$ G_n = F_1 + F_2 + &amp;hellip; + F_n$$
根據二元樹的定義，根節點一定大於左節點小於右節點，所以以 $i$ 節點為根的二元樹可以看成是 由 $1$ 到 $i - 1$ 構成的左子樹 加上 由 $i + 1$ 到 $n$ 構成的右子樹，也就是說
$$F_i = G_{i - 1} * G_{n - i}$$
所以遞迴式就跑出來了
$$G_n = G_0 * G_{n - 1} + G_1 * G_{n - 2} + &amp;hellip; + G_{n - 1} * G_0$$</description></item><item><title>Leetcode 45. Jump Game II</title><link>https://snow-ham1949.github.io/posts/leetcode-45-jump-game-ii/</link><pubDate>Fri, 04 Feb 2022 17:26:23 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-45-jump-game-ii/</guid><description>寒假因為很無聊就來刷題，絕對不是因為我很廢 :p
題目 link
作法 我是先想到 $O(n^2)$ 的做法，對於每個位置 $i$ 都去看前面的位置 $j$ 能不能走得更遠，如果可以的話就把 $i$ 的最小步數更新成走到 $j$ 的步數 +1（從 $j$ 到 $i$）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int jump(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); vector&amp;lt;int&amp;gt; dp(n, INT_MAX); dp[0] = 0; for (int i = 1; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; i; j++) { if (j + nums[j] &amp;gt;= i and dp[j] !</description></item></channel></rss>