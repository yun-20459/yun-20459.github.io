<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CSES on 隨寫日誌</title><link>https://snow-ham1949.github.io/tags/cses/</link><description>Recent content in CSES on 隨寫日誌</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>Erin Li</copyright><lastBuildDate>Mon, 03 Oct 2022 22:39:07 +0000</lastBuildDate><atom:link href="https://snow-ham1949.github.io/tags/cses/index.xml" rel="self" type="application/rss+xml"/><item><title>CSES Josephus Queries</title><link>https://snow-ham1949.github.io/posts/cses-josephus-queries/</link><pubDate>Mon, 03 Oct 2022 22:39:07 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/cses-josephus-queries/</guid><description>題目 給 $n$ 個圍成一圈的小孩，每 2 個人就移掉 2 個人中的第二個，問第 $k$ 個小孩被移掉的編號
作法 這題網路上有很多題解，我看的懂 tutorial 但實作都看不懂所以寫一下。 ps 是我隊友教我的她好棒
因為圍成一圈，所以說我們可以把要移掉的數目看成是 $\frac{n + 1}{2}$，這樣一來如果 $n$ 是奇數，被移掉的就會是所有的偶數跟 1，反之則是移掉所有的偶數。
那麼遞迴下去做的話，可以看成是把該移掉的人移掉之後重新編號成 1, 2, 3, &amp;hellip;，再把 index remap 回來，所以這時候就要看原本是奇數還是偶數來決定怎麼 remap。
舉例來說，如果 $n$ 是奇數，那第一輪拿完會變成 3, 5, 7, &amp;hellip;, n，這樣重新編號成 1, 2, 3, &amp;hellip;，就要 $2 \times \text{id} + 1$ remap 回來。如果 $n$ 是偶數的話，那第一輪拿完會變成 1, 3, 5, 7, &amp;hellip;, n，這樣重新編號成 1, 2, 3, &amp;hellip;，就要 $2 \times \text{id} - 1$ remap 回來。</description></item><item><title>CSES Tree Matching</title><link>https://snow-ham1949.github.io/posts/cses-tree-matching/</link><pubDate>Mon, 19 Sep 2022 21:51:48 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/cses-tree-matching/</guid><description>第一次接觸樹 dp OuO
題目 給一棵樹，找到最大的邊集合使得任兩邊不共享一個點，輸出集合大小。
作法 定義 如果是 array 版本的話（i.e. 給一個序列不能選相鄰的，最大化價值），比較容易可以想到轉移式 $dp(i) = max(v_i + dp(i - 2), dp(i - 1))$
轉成樹的版本的話，就需要在樹上面做 dp，對於一個節點 $u$ 有下面兩種情況
取一條跟 $v \in child(u)$ 有連接的邊，答案定義為 $dp_0(u)$ 不取任何跟 $v \in child(u)$ 有連接的邊，答案定義為 $dp_1(u)$ 為什麼沒有取兩條以上的 case 呢？因為如果取兩條以上的話 $u$ 就會變成那個共享的點。
所以從上面的定義可以知道答案是 $max(dp_0(1), dp_1(1))$
轉移式 $dp_1(u)$
因為不取任何跟 $v \in child(u)$ 有連接的邊，所以不管「跟 $v$ 的小孩有連接的邊」取不取都可以，所以答案就是
$dp_1(u) = \sum_{v \in child(u)} max(dp_0(v), dp_1(v))$
$dp_0(u)$
可以先處理取一條的部分，因為取了 $u \rightarrow v$ 這一條，所以「不取任何跟 $w \in child(v)$ 有連接的邊」是 $dp_1(v)$，再加上 $u \rightarrow v$ 這一條，就是 $dp_1(v) + 1$。</description></item><item><title>CSES List Removals</title><link>https://snow-ham1949.github.io/posts/cses-list-removals/</link><pubDate>Sun, 18 Sep 2022 19:18:46 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/cses-list-removals/</guid><description>題目 給定一個長度為 $n$ 的序列 $a$，給 $n$ 個詢問，對於每個詢問 $pos$，輸出位置為 $pos$ 的值並從序列中刪除。
作法 這題的技巧要用到「BIT 上二分搜」，可以想像如果一個數字還沒有被刪除，我們就將它的 presentation 記為 $1$，反之則為 $0$，那麼查詢位置在 $pos$ 的元素等於就是查找前綴和為 $pos$，且 presentation = 1 的位置。
至於二分搜要怎麼實作呢，BIT 的節點是根據 2 的冪次劃分的，所以每次可以嘗試擴展 2 的冪次，看現在的前綴和是不是小於詢問，如果是的話代表可以擴展。等於說我們在找 $\sum_{i = 1}^x presentation[i] &amp;lt; pos$ 的 $x$，如果現在的和還比詢問小的話就可以擴展。所以一路這樣擴展下去之後，我們會找到最大的 $x$ 符合上式，那麼 $x + 1$ 就是答案。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include &amp;lt;bits/stdc++.</description></item><item><title>CSES Hotel Queries</title><link>https://snow-ham1949.github.io/posts/cses-hotel-queries/</link><pubDate>Sat, 17 Sep 2022 23:13:51 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/cses-hotel-queries/</guid><description>題目 給一個序列 $a$，對於每個詢問 $x$ 找到最小的 $i$ 使得 $a[i] &amp;gt;= x$，並將 $a[i] -= x$。
作法 這題要用到的技巧是線段樹二分搜。
線段樹的每個節點可以存「節點包含的區間內最大的數」，所以對於每個詢問 $x$，我都可以去看是下面哪個 case
左子樹的最大值 $&amp;gt;= x$ -&amp;gt; 往左子樹遞迴查詢 右子樹的最大值 $&amp;gt;= x$ -&amp;gt; 往右子樹遞迴查詢 都小於 -&amp;gt; 答案 $= 0$ 實作就看 code
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include &amp;lt;bits/stdc++.</description></item><item><title>Sparse Table</title><link>https://snow-ham1949.github.io/posts/sparse-table/</link><pubDate>Sun, 04 Sep 2022 22:13:25 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/sparse-table/</guid><description>能幹嘛 區間最小/最大查詢，利用可以把區間拆成 $\log_2(\text{區間長度})$ 個長度為 2 的冪次的區間，達到 $O(N\log(N))$ pre-build, $O(1)$ 查詢。
（區間和查詢也可以，不過是 $O(\log(N))$，而且可以用前綴和 $O(1)$）
舉例來說，$[2, 10]$ 是一個長度為 9 的區間，那他就可以被拆成 $[2, 9] \cup [10, 10]$，如果我可以提前知道這兩個區間的答案，那我就知道組合起來的答案。
建 st 表的話可以看下面例題的 code， $st[i][j] :=$ 從 $i$ 開始長度為 $2^j$ 的區間的答案，那因為這樣的區間可以再拆成兩個長度為 $2^{j - 1}$ 的區間，所以可以用這兩個區間求答案。
btw 缺點是如果陣列值有改動的話就要重蓋 st 表，所以適用於不會改值的時候用。
例題 CSES-Static Range Minimum Queries
作法
就是 sparse table 模板題，不過這題的話不用跟求 sum 一樣拆成好幾個不重疊的區間，因為求 min 的話就算拆成兩個重疊的也沒關係，所以就暴力拆成兩個 $\log(r - l + 1)$ 長度的區間就可以查詢了。
code
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include &amp;lt;bits/stdc++.</description></item><item><title>CSES Round Trip</title><link>https://snow-ham1949.github.io/posts/cses-round-trip/</link><pubDate>Sun, 27 Feb 2022 22:41:56 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/cses-round-trip/</guid><description>我一直以為我會找環欸，結果其實是我會找但要印出來就不會，我就笨 :p
題目 link
找圖中隨便一個環然後印路徑，如果沒有就輸出 IMPOSSIBLE。
作法 就是 dfs 一下(?)，最近在試著改掉開全域的壞習慣 :p，主要是我想要怎麼記祖先想很久，覺得開 parent 陣列又太肥，後來想到當參數傳下去不就好了嗎，笨笨的 :p
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include &amp;lt;bits/stdc++.</description></item></channel></rss>