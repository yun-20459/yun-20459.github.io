<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Leetcode on 隨寫日誌</title><link>https://snow-ham1949.github.io/tags/leetcode/</link><description>Recent content in Leetcode on 隨寫日誌</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>Erin Li</copyright><lastBuildDate>Wed, 20 Jul 2022 14:07:36 +0000</lastBuildDate><atom:link href="https://snow-ham1949.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 792. Number of Matching Subsequences</title><link>https://snow-ham1949.github.io/posts/leetcode-792-number-of-matching-subsequences/</link><pubDate>Wed, 20 Jul 2022 14:07:36 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-792-number-of-matching-subsequences/</guid><description>試著記得每次都要寫複雜度（？
題目 link
作法 一開始看到 tag 以為真的要寫 trie，後來才發現不用（用 trie 我也不會寫），用二分搜就可以了。
概念是先去紀錄 s 每個字母有出現在哪裡，然後去遍歷每個 word，對於 word 裡的每一個字母，我都要能在 s 裡面找到比前一個字母在 s 裡面的位置更後面的位置（好拗口），這樣才符合 subsequence of string。
舉例來說
s = &amp;#34;abcd&amp;#34; words = [&amp;#34;ab&amp;#34;, &amp;#34;cb&amp;#34;] 顯然對於 &amp;quot;ab&amp;quot; 來說，我可以在 s 裡面找到 1 跟 2 這兩個位置，所以他是對的，但對於 &amp;quot;cb&amp;quot; 來說，c 的第一個位置就是 3 了，而 3 後面沒有 b 所以他是錯的。
假設 s 長度是 $L$，$words$ 陣列長度是 $N$，每個 word 長度是 $l$，複雜度會是 $O(LNlog(l))$。
class Solution { public: int numMatchingSubseq(string s, vector&amp;lt;string&amp;gt;&amp;amp; words) { vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; ch(26); int n = s.</description></item><item><title>Leetcode 629. K Inverse Pairs Array</title><link>https://snow-ham1949.github.io/posts/leetcode-629-k-inverse-pairs-array/</link><pubDate>Sun, 17 Jul 2022 21:27:49 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-629-k-inverse-pairs-array/</guid><description>題目 link
作法 $O(nk^2)$ 我以為會 TLE 然後剛剛測發現其實不會 QQ，可以定義 $dp[i][j]$ 是使用 1 ~ $i$ 的數字後，可以構成 $j$ 個 inversion pair 的數量，那答案就會是 $dp[n][k]$。
轉移式的話可以觀察，如果我現在已經放好 1~3 然後我要把 4 放進去這個序列裡面，我可以有下面這幾種放法
放法 造成的逆序數對 4xxx 3 x4xx 2 xx4x 1 xxx4 0 所以就可以發現這樣的轉移式
$dp[i][j] = dp[i - 1][j - k]$, $\forall k \in [0, i - 1]$
class Solution { public: int kInversePairs(int n, int k) { const int mod = 1e9 + 7; vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; dp(n + 1, vector&amp;lt;int&amp;gt;(k + 1, 1)); for (int i = 1; i &amp;lt;= n; i++) { for (int j = 0; j &amp;lt;= k; j++) { for (int k = 0; k &amp;lt;= min(K, N - 1); k++) { dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % mod; } } } return dp[n][k]; } }; $O(nk)$ 同樣的概念，只是剛剛的轉移式可以再優化</description></item><item><title>Leetcode 2305. Fair Distribution of Cookies</title><link>https://snow-ham1949.github.io/posts/leetcode-2305-fair-distribution-of-cookies/</link><pubDate>Thu, 14 Jul 2022 17:07:07 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-2305-fair-distribution-of-cookies/</guid><description>題目 link
作法 bit manipulation + dp 這題跟 這題 蠻像的，不過這次是要盡可能平均分然後輸出這樣分以後一個小孩最多可能拿到的餅乾數。
我一開始想跟 698 那題一樣做，不過這樣的話是沒辦法知道 max 的，因為只能用袋子分而不是直接拿餅乾分，所以要換一個方法。
定義 dp[i][mask] 為當人數有 $i$ 個的時候取的 subset 為 $mask$ 時，拿到最多餅乾的小孩的餅乾數量的最小值，就會有以下的轉移式
dp[i][mask] = min(dp[i][mask], max(dp[i - 1][mask ^ submask], sum[submask]))
意思是說在這群小孩裡面有個小孩拿了 submask 這樣的 subset，剩下的小孩拿其他的，看最大值會是多少，然後因為我最後要的是最小化最大值，所以取 min。
關於 enumerating submask of mask 可以看 這篇 講解
class Solution { public: int distributeCookies(vector&amp;lt;int&amp;gt;&amp;amp; cookies, int k) { int n = cookies.size(); vector&amp;lt;int&amp;gt; sum(1 &amp;lt;&amp;lt; n, 0); for (int mask = 0; mask &amp;lt; (1 &amp;lt;&amp;lt; n); mask++) { for (int i = 0; i &amp;lt; n; i++) { if ((mask &amp;gt;&amp;gt; i) &amp;amp; 1) { sum[mask] += cookies[i]; } } } vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; dp(k + 1, vector&amp;lt;int&amp;gt;(1 &amp;lt;&amp;lt; n, INT_MAX)); dp[0][0] = 0; for (int person = 1; person &amp;lt;= k; person++) { for (int mask = 0; mask &amp;lt; (1 &amp;lt;&amp;lt; n); mask++) { for (int submask = mask; submask; submask = (submask - 1)&amp;amp;mask) { dp[person][mask] = min(dp[person][mask], max(sum[submask], dp[person - 1][mask ^ submask])); } } } return dp[k][(1 &amp;lt;&amp;lt; n) - 1]; } }; 剪枝 dfs code by 蕭啟湘</description></item><item><title>Leetcode 698. Partition to K Equal Sum Subsets</title><link>https://snow-ham1949.github.io/posts/leetcode-698-partition-to-k-equal-sum-subsets/</link><pubDate>Wed, 13 Jul 2022 18:17:01 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-698-partition-to-k-equal-sum-subsets/</guid><description>好像比較了解 bit manipulation 可以幹嘛了（？）
題目 link
做法 這題是 這題 的進化版（？），要分成 $k$ 堆，一樣可以用 bit + dp 做，然後這邊還有一個小技巧是直接用餘數，這樣就可以直接在最後判是不是等於 0，如果不用餘數的話可能就要寫個 if 或者用更複雜的方式去判現在這個 element 能不能被放進這個 subset
class Solution { public: bool canPartitionKSubsets(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { int sum = 0; for (int num : nums) sum += num; if (sum % k) return false; int target = sum / k; int n = nums.size(); vector&amp;lt;int&amp;gt; dp(1 &amp;lt;&amp;lt; n, -1); dp[0] = 0; sort(nums.begin(), nums.end()); for (int mask = 0; mask &amp;lt; (1 &amp;lt;&amp;lt; n); mask++) { if (dp[mask] == -1) continue; for (int j = 0; j &amp;lt; n; j++) { if (!</description></item><item><title>Leetcode 473. Matchsticks to Square</title><link>https://snow-ham1949.github.io/posts/leetcode-473-matchsticks-to-square/</link><pubDate>Tue, 12 Jul 2022 23:20:53 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-473-matchsticks-to-square/</guid><description>不會 dp 也不會 bit manipulation QAQ
題目 link
作法 dfs 一個最簡單的做法可以直接 recursion, code 如下
class Solution { public: bool chk(vector&amp;lt;int&amp;gt;&amp;amp; side, vector&amp;lt;int&amp;gt;&amp;amp; matches, int id, int n) { if (id == n) { return side[0] == side[1] and side[1] == side[2] and side[2] == side[3]; } for (int i = 0; i &amp;lt; 4; i++) { side[i] += matches[id]; if (chk(side, matches, id + 1, n)) return true; side[i] -= matches[id]; } return false; } bool makesquare(vector&amp;lt;int&amp;gt;&amp;amp; matches) { int n = match.</description></item><item><title>Leetcode 1696. Jump Game VI</title><link>https://snow-ham1949.github.io/posts/leetcode-1696-jump-game-vi/</link><pubDate>Sun, 10 Jul 2022 00:19:10 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-1696-jump-game-vi/</guid><description>題目 link
作法 令 dp[i] 為以 $i$ 為起點到終點能獲得的最大分數。如果枚舉可以走的範圍內最大的話複雜度會是 $O(nk)$ 會 TLE，所以可以用 deque 或是 priority_queue 來優化，維護一個可以走的範圍內的單調隊列或者 heap，就可以在 $O(1)$ 或是 $O(logk)$ 內拿到最大值了。
下面兩種 code 分別用 deque 和 priority_queue 寫， deque 版本是從起點開始做，priority_queue 版本是從終點開始做
deque 版本
class Solution { public: int maxResult(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { int n = nums.size(); vector&amp;lt;int&amp;gt; dp(n, 0); deque&amp;lt;int&amp;gt; dq; dp[0] = nums[0]; dq.push_back(0); for (int i = 1; i &amp;lt; n; i++) { if (dq.front() &amp;lt; i - k) dq.</description></item><item><title>Leetcode 32. Longest Valid Parentheses</title><link>https://snow-ham1949.github.io/posts/leetcode-32-longest-valid-parentheses/</link><pubDate>Thu, 07 Jul 2022 21:17:42 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-32-longest-valid-parentheses/</guid><description>我真的不會 dp QwQ
題目 link
作法 可以先從基礎題開始想，就是判合法括號字串，這個用 stack 就可以解決（其實這題也可，但我想練 dp），從這個的想法出發的話，可以先想到
如果前一個是 ( 後一個是 )，那就有一個長度為 2 的合法括號字串 如果以 dp[i] 來記錄以 $i 為結尾最長合法括號字串長度的話， 1. 可以寫成 dp[i] = dp[i - 1] + 2，要注意這個是建立在你已經知道前面有 ( 了。
接下來再考慮這個 case ()()，因為 dp[i] 要記錄的是以 $i$ 為結尾最長合法括號字串長度，所以前面合法括號字串長度也要算進來，這個的算法可以利用現在紀錄的長度跟 index 來算。
以這個 case 來說，它其實可以切成兩個 ()，在算第二個的時候按照上面的式子只會記錄到長度 2，，所以要去看 i - dp[i] 這個 index dp 值存的是多少然後加起來。
就有
if (i - dp[i] &amp;gt; 0) dp[i] += dp[i - dp[i]] 最後就是看整個字串然後一邊用 dp 值更新答案
class Solution { public: int longestValidParentheses(string s) { int n = s.</description></item><item><title>Leetcode 1354. Construct Target Array With Multiple Sums</title><link>https://snow-ham1949.github.io/posts/leetcode-1354-construct-target-array-with-multiple-sums/</link><pubDate>Fri, 24 Jun 2022 20:55:17 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-1354-construct-target-array-with-multiple-sums/</guid><description>題目 link
作法 我是看 hint 才會的 QQ，hint 就是這題其實要反著做，就是說如果 target array 是可以被構造出來的話，逆推回去就應該是對的。
作法是把最大值一個一個從 priority_queue 中拔出來處理，有三種情況應該要 return false
val &amp;lt;= sum 可以假設被修改前值是 $x$，剩下的值總和是 $y$，所以修改後的值是 $x+y$。 從 code 裡可以看到現在 $sum = y$，所以理論上是不會大於 $x + y$ 的。
sum &amp;lt; 1 根據 1. 可以發現既然 $sum = y$，那因為要構造的陣列值都是 1 ，所以如果小於 1 就是錯的。
sum != 1 and val == 0 這邊牽扯到我上面的一點實作方式，因為同一個值可能被操作很多次，所以可以直接 %=sum 找到操作前的值，再把它加上 $sum$ 就是修改前的陣列總和。那這邊需要特判[1, 1]這個 case，因為雖然理論上val == 0會是錯的（因為這代表修改前的值是 0 &amp;lt; 1），但是可以發現這個 case 在這裡會是錯的，所以需要特判掉。
class Solution { public: bool isPossible(vector&amp;lt;int&amp;gt;&amp;amp; target) { priority_queue&amp;lt;int&amp;gt; pq; unsigned int sum = 0; for (int num : target) { pq.</description></item><item><title>Leetcode 96. Unique Binary Search Trees</title><link>https://snow-ham1949.github.io/posts/leetcode-96-unique-binary-search-trees/</link><pubDate>Sat, 12 Feb 2022 19:13:27 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-96-unique-binary-search-trees/</guid><description>忘記數學了所以來複習一下 :p
題目 link
作法 如果假設有 $n$ 個節點的二元樹有 $G_n$ 個，其中以 $i$ 節點為根的數目有 $F_i$ 個，那麼 $$ G_n = F_1 + F_2 + &amp;hellip; + F_n$$
根據二元樹的定義，根節點一定大於左節點小於右節點，所以以 $i$ 節點為根的二元樹可以看成是 由 $1$ 到 $i - 1$ 構成的左子樹 加上 由 $i + 1$ 到 $n$ 構成的右子樹，也就是說 $$F_i = G_{i - 1} * G_{n - i}$$
所以遞迴式就跑出來了
$$G_n = G_0 * G_{n - 1} + G_1 * G_{n - 2} + &amp;hellip; + G_{n - 1} * G_0$$</description></item><item><title>Leetcode 45. Jump Game II</title><link>https://snow-ham1949.github.io/posts/leetcode-45-jump-game-ii/</link><pubDate>Fri, 04 Feb 2022 17:26:23 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-45-jump-game-ii/</guid><description>寒假因為很無聊就來刷題，絕對不是因為我很廢 :p
題目 link
作法 我是先想到 $O(n^2)$ 的做法，對於每個位置 $i$ 都去看前面的位置 $j$ 能不能走得更遠，如果可以的話就把 $i$ 的最小步數更新成走到 $j$ 的步數 +1（從 $j$ 到 $i$）
class Solution { public: int jump(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); vector&amp;lt;int&amp;gt; dp(n, INT_MAX); dp[0] = 0; for (int i = 1; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; i; j++) { if (j + nums[j] &amp;gt;= i and dp[j] != INT_MAX) { dp[i] = min(dp[i], dp[j] + 1); } } } return dp[n - 1]; } }; 然後這題其實可以 $O(n)$，概念是一樣的，每個位置都去看可以走到多遠，如果走到前一次算出來最遠的地方，就更新成現在算出來可以到達最遠的地方，在到達之前就一直更新，就不用每次都回去重複算到底怎麼走最快。</description></item></channel></rss>