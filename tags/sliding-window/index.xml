<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sliding Window on 隨寫日誌</title><link>https://yun-20459.github.io/tags/sliding-window/</link><description>Recent content in Sliding Window on 隨寫日誌</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>Erin Li</copyright><lastBuildDate>Sun, 17 Jul 2022 21:27:49 +0000</lastBuildDate><atom:link href="https://yun-20459.github.io/tags/sliding-window/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 629. K Inverse Pairs Array</title><link>https://yun-20459.github.io/posts/leetcode-629-k-inverse-pairs-array/</link><pubDate>Sun, 17 Jul 2022 21:27:49 +0000</pubDate><guid>https://yun-20459.github.io/posts/leetcode-629-k-inverse-pairs-array/</guid><description>題目 link
作法 $O(nk^2)$ 我以為會 TLE 然後剛剛測發現其實不會 QQ，可以定義 $dp[i][j]$ 是使用 1 ~ $i$ 的數字後，可以構成 $j$ 個 inversion pair 的數量，那答案就會是 $dp[n][k]$。
轉移式的話可以觀察，如果我現在已經放好 1~3 然後我要把 4 放進去這個序列裡面，我可以有下面這幾種放法
放法 造成的逆序數對 4xxx 3 x4xx 2 xx4x 1 xxx4 0 所以就可以發現這樣的轉移式
$dp[i][j] = dp[i - 1][j - k]$, $\forall k \in [0, i - 1]$
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int kInversePairs(int n, int k) { const int mod = 1e9 + 7; vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; dp(n + 1, vector&amp;lt;int&amp;gt;(k + 1, 1)); for (int i = 1; i &amp;lt;= n; i++) { for (int j = 0; j &amp;lt;= k; j++) { for (int k = 0; k &amp;lt;= min(K, N - 1); k++) { dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % mod; } } } return dp[n][k]; } }; $O(nk)$ 同樣的概念，只是剛剛的轉移式可以再優化</description></item></channel></rss>