<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bit Manipulation on 隨寫日誌</title><link>https://yun-20459.github.io/tags/bit-manipulation/</link><description>Recent content in Bit Manipulation on 隨寫日誌</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>Erin Li</copyright><lastBuildDate>Thu, 14 Jul 2022 17:07:07 +0000</lastBuildDate><atom:link href="https://yun-20459.github.io/tags/bit-manipulation/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 2305. Fair Distribution of Cookies</title><link>https://yun-20459.github.io/posts/leetcode-2305-fair-distribution-of-cookies/</link><pubDate>Thu, 14 Jul 2022 17:07:07 +0000</pubDate><guid>https://yun-20459.github.io/posts/leetcode-2305-fair-distribution-of-cookies/</guid><description>題目 link
作法 bit manipulation + dp 這題跟 這題 蠻像的，不過這次是要盡可能平均分然後輸出這樣分以後一個小孩最多可能拿到的餅乾數。
我一開始想跟 698 那題一樣做，不過這樣的話是沒辦法知道 max 的，因為只能用袋子分而不是直接拿餅乾分，所以要換一個方法。
定義 dp[i][mask] 為當人數有 $i$ 個的時候取的 subset 為 $mask$ 時，拿到最多餅乾的小孩的餅乾數量的最小值，就會有以下的轉移式
dp[i][mask] = min(dp[i][mask], max(dp[i - 1][mask ^ submask], sum[submask]))
意思是說在這群小孩裡面有個小孩拿了 submask 這樣的 subset，剩下的小孩拿其他的，看最大值會是多少，然後因為我最後要的是最小化最大值，所以取 min。
關於 enumerating submask of mask 可以看 這篇 講解
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: int distributeCookies(vector&amp;lt;int&amp;gt;&amp;amp; cookies, int k) { int n = cookies.</description></item><item><title>Leetcode 698. Partition to K Equal Sum Subsets</title><link>https://yun-20459.github.io/posts/leetcode-698-partition-to-k-equal-sum-subsets/</link><pubDate>Wed, 13 Jul 2022 18:17:01 +0000</pubDate><guid>https://yun-20459.github.io/posts/leetcode-698-partition-to-k-equal-sum-subsets/</guid><description>好像比較了解 bit manipulation 可以幹嘛了（？）
題目 link
做法 這題是 這題 的進化版（？），要分成 $k$ 堆，一樣可以用 bit + dp 做，然後這邊還有一個小技巧是直接用餘數，這樣就可以直接在最後判是不是等於 0，如果不用餘數的話可能就要寫個 if 或者用更複雜的方式去判現在這個 element 能不能被放進這個 subset
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: bool canPartitionKSubsets(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { int sum = 0; for (int num : nums) sum += num; if (sum % k) return false; int target = sum / k; int n = nums.</description></item><item><title>Leetcode 473. Matchsticks to Square</title><link>https://yun-20459.github.io/posts/leetcode-473-matchsticks-to-square/</link><pubDate>Tue, 12 Jul 2022 23:20:53 +0000</pubDate><guid>https://yun-20459.github.io/posts/leetcode-473-matchsticks-to-square/</guid><description>不會 dp 也不會 bit manipulation QAQ
題目 link
作法 dfs 一個最簡單的做法可以直接 recursion, code 如下
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: bool chk(vector&amp;lt;int&amp;gt;&amp;amp; side, vector&amp;lt;int&amp;gt;&amp;amp; matches, int id, int n) { if (id == n) { return side[0] == side[1] and side[1] == side[2] and side[2] == side[3]; } for (int i = 0; i &amp;lt; 4; i++) { side[i] += matches[id]; if (chk(side, matches, id + 1, n)) return true; side[i] -= matches[id]; } return false; } bool makesquare(vector&amp;lt;int&amp;gt;&amp;amp; matches) { int n = match.</description></item></channel></rss>