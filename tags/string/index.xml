<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>String on 隨寫日誌</title><link>https://yun-20459.github.io/tags/string/</link><description>Recent content in String on 隨寫日誌</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>Erin Li</copyright><lastBuildDate>Mon, 24 Oct 2022 21:57:08 +0000</lastBuildDate><atom:link href="https://yun-20459.github.io/tags/string/index.xml" rel="self" type="application/rss+xml"/><item><title>Codeforces 1635D. Infinite Set</title><link>https://yun-20459.github.io/posts/codeforces-1635d-infinite-set/</link><pubDate>Mon, 24 Oct 2022 21:57:08 +0000</pubDate><guid>https://yun-20459.github.io/posts/codeforces-1635d-infinite-set/</guid><description>這題好難，我看了好多遍別人的題解才懂 QwQ
題目 給一個陣列，考慮一個無限的集合 $S$ 由符合以下條件之一的 $x$ 構成
$x = a[i]$ $x = 2 * y + 1$ and $y \in S$ $x = 4 * y$ and $y \in S$ 問在集合 $S$ 中有多少元素小於 $2^p$，答案很大要 mod $1e9+7$
作法 因為 $p$ 的範圍會到 2e5，所以要用二進制來想這題。
對於一個二進位制為 $t$ 的數字，可以想像操作二就是左移一位然後末位補 1，操作二就是左移兩位（這邊就有點像 string）。所以可以觀察出一個結論，就是對於一個數字，把它增加 $i$ 位的方法有 $dp_i$ 種，這裡的 $dp$ 就是費波那契數列。
那這跟答案有什麼關係呢，假設一個二進位制為 $t$ 的數字存在在 $a$ 之中，那麼他擴展出的數字要小於 $p$ 的話，他擴展出的數字的數量就會是 $\sum_{i = 0}^{p - t} dp_i$，也就是不擴展、擴展一位、擴展兩位&amp;hellip;，那這件事情可以透過在算費波那契數列的時候算前綴和得到。
接下來考慮是不是每個 $a[i]$ 都會對答案有貢獻，其實不是這樣，因為 $S$ 是一個 set，不會有重複的數字出現，所以如果會重複出現就不用算。那題解的做法是說那就把會產生的數字想成一棵樹，我一直去看產生 $x$ 的 parent 有沒有已經被 create 過，如果有的話，那就代表 $x$ 已經被前面的數字（也就是 parent） create 過了，那就不能算進答案裡面（因為已經算過了），在這邊的話 parent 的意思就是說看他能不能逆推操作二或操作三。</description></item><item><title>Leetcode 792. Number of Matching Subsequences</title><link>https://yun-20459.github.io/posts/leetcode-792-number-of-matching-subsequences/</link><pubDate>Wed, 20 Jul 2022 14:07:36 +0000</pubDate><guid>https://yun-20459.github.io/posts/leetcode-792-number-of-matching-subsequences/</guid><description>試著記得每次都要寫複雜度（？
題目 link
作法 一開始看到 tag 以為真的要寫 trie，後來才發現不用（用 trie 我也不會寫），用二分搜就可以了。
概念是先去紀錄 s 每個字母有出現在哪裡，然後去遍歷每個 word，對於 word 裡的每一個字母，我都要能在 s 裡面找到比前一個字母在 s 裡面的位置更後面的位置（好拗口），這樣才符合 subsequence of string。
舉例來說
1 2 s = &amp;#34;abcd&amp;#34; words = [&amp;#34;ab&amp;#34;, &amp;#34;cb&amp;#34;] 顯然對於 &amp;quot;ab&amp;quot; 來說，我可以在 s 裡面找到 1 跟 2 這兩個位置，所以他是對的，但對於 &amp;quot;cb&amp;quot; 來說，c 的第一個位置就是 3 了，而 3 後面沒有 b 所以他是錯的。
假設 s 長度是 $L$，$words$ 陣列長度是 $N$，每個 word 長度是 $l$，複雜度會是 $O(LNlog(l))$。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: int numMatchingSubseq(string s, vector&amp;lt;string&amp;gt;&amp;amp; words) { vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; ch(26); int n = s.</description></item></channel></rss>