<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Binary Search on 隨寫日誌</title><link>https://snow-ham1949.github.io/tags/binary-search/</link><description>Recent content in Binary Search on 隨寫日誌</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>Erin Li</copyright><lastBuildDate>Mon, 04 Sep 2023 21:49:45 +0000</lastBuildDate><atom:link href="https://snow-ham1949.github.io/tags/binary-search/index.xml" rel="self" type="application/rss+xml"/><item><title>浮點數二分搜技巧</title><link>https://snow-ham1949.github.io/posts/%E6%B5%AE%E9%BB%9E%E6%95%B8%E4%BA%8C%E5%88%86%E6%90%9C%E6%8A%80%E5%B7%A7/</link><pubDate>Mon, 04 Sep 2023 21:49:45 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/%E6%B5%AE%E9%BB%9E%E6%95%B8%E4%BA%8C%E5%88%86%E6%90%9C%E6%8A%80%E5%B7%A7/</guid><description>今天寫了這題才知道原來浮點數二分搜要這樣寫。
原本我以為應該是要根據他想要的浮點數誤誤差當作 eps，然後寫成這樣
while (r - l &amp;gt; eps) { do binary search } 但那樣的話會 TLE，因為 r - l 的精度誤差有可能導致這個 while 會變成一個無窮迴圈，就是其實他已經達到 eps 了但是減起來大於。
所以應該要根據你的範圍跟他要的浮點數誤差來估計要砍半幾次，砍一次的精度是 0.5，所以砍 10 次的話大概會是 1e-3，所以根據你要的範圍 / 浮點數誤差 / 3 * 10 大概就是你要砍半的次數。
順便附上這題我的 code，我覺得想法不難只是需要知道浮點數二分搜怎麼寫而已。
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef long long ll; typedef pair&amp;lt;int, int&amp;gt; pii; typedef pair&amp;lt;ll, ll&amp;gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #ifdef debug void trace_() { cerr &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; } template &amp;lt;typename T1, typename.</description></item><item><title>二分搜技巧</title><link>https://snow-ham1949.github.io/posts/%E4%BA%8C%E5%88%86%E6%90%9C%E6%8A%80%E5%B7%A7/</link><pubDate>Sun, 06 Aug 2023 19:38:47 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/%E4%BA%8C%E5%88%86%E6%90%9C%E6%8A%80%E5%B7%A7/</guid><description>上次團練的時候被學長建議了這種寫法，所以記錄一下。以往我都是寫
while (l &amp;lt; r) { int m = (l + r) &amp;gt;&amp;gt; 1; if (chk(m)) r = m; else l = m + 1; } 但有時候就會搞不清楚自己到底想要取什麼 = =，有點笨，所以換成下面的寫法
while (r - l &amp;gt; 1) { int m = (l + r) &amp;gt;&amp;gt; 1; if (chk(m)) l = m; else r = m; } 這樣的寫法可以解釋成，如果 check mid 是對的，那麼我就提升左界，找到符合資格最大的，不然就下壓右界，然後因為停止條件是 $r - l == 1$，所以到時候 $l$ 就是合法的最大界，$r$ 會是不合法的最小界。</description></item><item><title>Leetcode 792. Number of Matching Subsequences</title><link>https://snow-ham1949.github.io/posts/leetcode-792-number-of-matching-subsequences/</link><pubDate>Wed, 20 Jul 2022 14:07:36 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-792-number-of-matching-subsequences/</guid><description>試著記得每次都要寫複雜度（？
題目 link
作法 一開始看到 tag 以為真的要寫 trie，後來才發現不用（用 trie 我也不會寫），用二分搜就可以了。
概念是先去紀錄 s 每個字母有出現在哪裡，然後去遍歷每個 word，對於 word 裡的每一個字母，我都要能在 s 裡面找到比前一個字母在 s 裡面的位置更後面的位置（好拗口），這樣才符合 subsequence of string。
舉例來說
s = &amp;#34;abcd&amp;#34; words = [&amp;#34;ab&amp;#34;, &amp;#34;cb&amp;#34;] 顯然對於 &amp;quot;ab&amp;quot; 來說，我可以在 s 裡面找到 1 跟 2 這兩個位置，所以他是對的，但對於 &amp;quot;cb&amp;quot; 來說，c 的第一個位置就是 3 了，而 3 後面沒有 b 所以他是錯的。
假設 s 長度是 $L$，$words$ 陣列長度是 $N$，每個 word 長度是 $l$，複雜度會是 $O(LNlog(l))$。
class Solution { public: int numMatchingSubseq(string s, vector&amp;lt;string&amp;gt;&amp;amp; words) { vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; ch(26); int n = s.</description></item></channel></rss>