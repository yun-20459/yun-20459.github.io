<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Codeforces on 隨寫日誌</title><link>https://yun-20459.github.io/tags/codeforces/</link><description>Recent content in Codeforces on 隨寫日誌</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>Erin Li</copyright><lastBuildDate>Mon, 04 Sep 2023 21:49:45 +0000</lastBuildDate><atom:link href="https://yun-20459.github.io/tags/codeforces/index.xml" rel="self" type="application/rss+xml"/><item><title>浮點數二分搜技巧</title><link>https://yun-20459.github.io/posts/%E6%B5%AE%E9%BB%9E%E6%95%B8%E4%BA%8C%E5%88%86%E6%90%9C%E6%8A%80%E5%B7%A7/</link><pubDate>Mon, 04 Sep 2023 21:49:45 +0000</pubDate><guid>https://yun-20459.github.io/posts/%E6%B5%AE%E9%BB%9E%E6%95%B8%E4%BA%8C%E5%88%86%E6%90%9C%E6%8A%80%E5%B7%A7/</guid><description>今天寫了這題才知道原來浮點數二分搜要這樣寫。
原本我以為應該是要根據他想要的浮點數誤誤差當作 eps，然後寫成這樣
1 2 3 while (r - l &amp;gt; eps) { do binary search } 但那樣的話會 TLE，因為 r - l 的精度誤差有可能導致這個 while 會變成一個無窮迴圈，就是其實他已經達到 eps 了但是減起來大於。
所以應該要根據你的範圍跟他要的浮點數誤差來估計要砍半幾次，砍一次的精度是 0.5，所以砍 10 次的話大概會是 1e-3，所以根據你要的範圍 / 浮點數誤差 / 3 * 10 大概就是你要砍半的次數。
順便附上這題我的 code，我覺得想法不難只是需要知道浮點數二分搜怎麼寫而已。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include &amp;lt;bits/stdc++.</description></item><item><title>Codeforces 1635D. Infinite Set</title><link>https://yun-20459.github.io/posts/codeforces-1635d-infinite-set/</link><pubDate>Mon, 24 Oct 2022 21:57:08 +0000</pubDate><guid>https://yun-20459.github.io/posts/codeforces-1635d-infinite-set/</guid><description>這題好難，我看了好多遍別人的題解才懂 QwQ
題目 給一個陣列，考慮一個無限的集合 $S$ 由符合以下條件之一的 $x$ 構成
$x = a[i]$ $x = 2 * y + 1$ and $y \in S$ $x = 4 * y$ and $y \in S$ 問在集合 $S$ 中有多少元素小於 $2^p$，答案很大要 mod $1e9+7$
作法 因為 $p$ 的範圍會到 2e5，所以要用二進制來想這題。
對於一個二進位制為 $t$ 的數字，可以想像操作二就是左移一位然後末位補 1，操作二就是左移兩位（這邊就有點像 string）。所以可以觀察出一個結論，就是對於一個數字，把它增加 $i$ 位的方法有 $dp_i$ 種，這裡的 $dp$ 就是費波那契數列。
那這跟答案有什麼關係呢，假設一個二進位制為 $t$ 的數字存在在 $a$ 之中，那麼他擴展出的數字要小於 $p$ 的話，他擴展出的數字的數量就會是 $\sum_{i = 0}^{p - t} dp_i$，也就是不擴展、擴展一位、擴展兩位&amp;hellip;，那這件事情可以透過在算費波那契數列的時候算前綴和得到。
接下來考慮是不是每個 $a[i]$ 都會對答案有貢獻，其實不是這樣，因為 $S$ 是一個 set，不會有重複的數字出現，所以如果會重複出現就不用算。那題解的做法是說那就把會產生的數字想成一棵樹，我一直去看產生 $x$ 的 parent 有沒有已經被 create 過，如果有的話，那就代表 $x$ 已經被前面的數字（也就是 parent） create 過了，那就不能算進答案裡面（因為已經算過了），在這邊的話 parent 的意思就是說看他能不能逆推操作二或操作三。</description></item><item><title>Codeforces 986B. Petr and Permutations</title><link>https://yun-20459.github.io/posts/codeforces-986b-petr-and-permutations/</link><pubDate>Fri, 22 Jul 2022 13:54:14 +0000</pubDate><guid>https://yun-20459.github.io/posts/codeforces-986b-petr-and-permutations/</guid><description>題目 有一個陣列 ${1, 2, &amp;hellip;, N}, (N \leq 10^6)$，Petr 喜歡對序列執行 $3n$ 次任取兩個數字交換的操作，Um_nik 喜歡做 $7n + 1$ 次，給定一個操作後的陣列，求是誰操作的。
作法 把 index 跟陣列數值想成是圖中有連接的點的話，一開始未操作的陣列會有 $n$ 個自環，每一次操作會增加或減少一個環，由 $3n$ 跟 $7n + 1$ 的奇偶性不同可以判斷是誰操作的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include &amp;lt;bits/stdc++.</description></item></channel></rss>