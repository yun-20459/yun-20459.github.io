[{"contents":"真的好不會做這種題喔 QQ\n題目\n解其實意外的簡單，如果 $m = 1$ 的話那一開始 player 1 就輸了，剩下的情況可以看 $n \\mod 2$，因為 player 2 最優的操作就是 player 1 做什麼他就做什麼，所以如果偶數個 tower，那代表最後只剩下高度為 1 的 tower 的時候剛好換到 player 1，所以 player 1 輸，相反的如果有奇數個 tower，那最後只剩下高度為 1 的 tower 的時候換到 player 2，所以 player 2 輸。\n","permalink":"https://yun-20459.github.io/posts/hackerrank-tower-breaker-%E9%A1%8C%E8%A7%A3/","tags":["game"],"title":"Hackerrank Tower Breaker 題解"},{"contents":"朋友的連結 \u0026gt; \u0026lt; UJ\u0026rsquo;s blog\n","permalink":"https://yun-20459.github.io/resources/","tags":[],"title":"Resources"},{"contents":"這是二號標題 1 2 3 4 5 6 7 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello world!\\n\u0026#34;; } 1 2 3 hexo c hexo g hexo d mathjax\n$x + y = z$\n","permalink":"https://yun-20459.github.io/posts/test/","tags":["test","testing"],"title":"Test"},{"contents":"修的課程 資訊系必修：自動機與形式語言、計算機結構\n資訊系選修：三維電腦視覺與深度學習應用\n自動機與形式語言 開課教授：林忠緯\n涼度：2/5\n甜度：4/5\n我去年修另一個班，上課都聽得懂結果考試完全不會寫，今年就換成忠緯試試看。這科感覺真的要大量刷題才會比較有感覺，不然我覺得上課老師教的都還算清楚，應該不太會有聽不懂的問題，問題應該都會是出在題目不會寫。我覺得沒有很涼，但可能是因為我數學沒有很好，甜度的話因為有調一點分所以給 4 分 \u0026gt; \u0026lt;\n計算機結構 開課教授：楊佳玲\n涼度：1/5\n甜度：5/5\n一樣去年今年都修的課，我就爛。我覺得做考古題是沒有用的，有真的去讀一些額外的東西可能比較有用。涼度的話每週都有討論課，討論題目＋小考，要實體出席有點麻煩，然後是翻轉教學，回家要先聽，上課還是 3 小時。甜度的話因為老師把我調了應該不少分所以給滿分。\n三維電腦視覺與深度學習應用 開課教授：陳祝嵩\n涼度：1/5\n甜度：3/5\n簡稱 3DCV，對於想了解 2D -\u0026gt; 3D 的 CV 的人推推，講解很詳細，作業也有一些挑戰性，同時也可以學到很多東西，期中考超級難，分數因為沒有調分所以給 3 分 \u0026gt; \u0026lt;\n感想區 一直忘記發 :p\n","permalink":"https://yun-20459.github.io/posts/112-1-%E4%BF%AE%E8%AA%B2%E5%BF%83%E5%BE%97/","tags":["class"],"title":"112-1 修課心得"},{"contents":"今天寫了這題才知道原來浮點數二分搜要這樣寫。\n原本我以為應該是要根據他想要的浮點數誤誤差當作 eps，然後寫成這樣\n1 2 3 while (r - l \u0026gt; eps) { do binary search } 但那樣的話會 TLE，因為 r - l 的精度誤差有可能導致這個 while 會變成一個無窮迴圈，就是其實他已經達到 eps 了但是減起來大於。\n所以應該要根據你的範圍跟他要的浮點數誤差來估計要砍半幾次，砍一次的精度是 0.5，所以砍 10 次的話大概會是 1e-3，所以根據你要的範圍 / 浮點數誤差 / 3 * 10 大概就是你要砍半的次數。\n順便附上這題我的 code，我覺得想法不難只是需要知道浮點數二分搜怎麼寫而已。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #ifdef debug void trace_() { cerr \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } template \u0026lt;typename T1, typename... T2\u0026gt; void trace_(T1 t1, T2... t2) { cerr \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; t1; trace_(t2...); } #define trace(...) cerr \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; #__VA_ARGS__ \u0026lt;\u0026lt; \u0026#34;] :\u0026#34;, trace_(__VA_ARGS__); #else #define trace(...) 49 #endif void solve() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;double\u0026gt; p(n), v(n); for (double \u0026amp;x : p) cin \u0026gt;\u0026gt; x; for (double \u0026amp;x : v) cin \u0026gt;\u0026gt; x; auto chk = [\u0026amp;](double x) { // check if everyone can meet at a point after x seconds double lb = -1, ub = 1e9 + 1; for (int i = 0; i \u0026lt; n; i++) { lb = max(lb, p[i] - v[i] * x); ub = min(ub, p[i] + v[i] * x); } if (lb \u0026lt;= ub) return true; return false; }; double l = 0, r = 6e14; int C = 100; while (C--) { double m = (l + r) / 2.0; if (chk(m)) r = m; else l = m; } cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(15) \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } /* CheckList: 1. long long 2. mod 3. template 4. input/output format/content 5. test sample input/output */ int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } ","permalink":"https://yun-20459.github.io/posts/%E6%B5%AE%E9%BB%9E%E6%95%B8%E4%BA%8C%E5%88%86%E6%90%9C%E6%8A%80%E5%B7%A7/","tags":["binary search","Codeforces"],"title":"浮點數二分搜技巧"},{"contents":"A - tcdr 直接跳過 aeiou 輸出就好\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; void solve() { string s; cin \u0026gt;\u0026gt; s; for (int i = 0; s[i]; i++) { if (s[i] == \u0026#39;a\u0026#39; || s[i] == \u0026#39;e\u0026#39; || s[i] == \u0026#39;i\u0026#39; || s[i] == \u0026#39;o\u0026#39; || s[i] == \u0026#39;u\u0026#39;) continue; else cout \u0026lt;\u0026lt; s[i]; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } /* CheckList: 1. long long 2. mod 3. template 4. input/output format/content 5. test sample input/output */ int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } B - The Middle Day 算出總和之後 / 2，然後一個一個月慢慢算現在有沒有超過就好\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; void solve() { int m; cin \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; d(m); int sum = 0; for (int \u0026amp;x : d) { cin \u0026gt;\u0026gt; x; sum += x; } sum /= 2; for (int i = 0; i \u0026lt; m; i++) { if (sum \u0026gt;= d[i]) sum -= d[i]; else { cout \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sum + 1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return; } } } /* CheckList: 1. long long 2. mod 3. template 4. input/output format/content 5. test sample input/output */ int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } C - Flavors 直接分兩個 case 算，如果最大的兩個不同 flavor 的話，那答案一定是他們相加，不然就去把所有 flavor 的最大拿出來，然後拿兩個最大的相加就好。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; void solve() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;pii\u0026gt; v(n); for (auto \u0026amp;p : v) cin \u0026gt;\u0026gt; p.Y \u0026gt;\u0026gt; p.X; sort(ALL(v)); ll res = 0; if (v[n - 1].Y == v[n - 2].Y) { res = v[n - 1].X + v[n - 2].X / 2; vector\u0026lt;int\u0026gt; mxf(n + 1, -1); for (int i = 0; i \u0026lt; n; i++) { mxf[v[i].Y] = max(mxf[v[i].Y], v[i].X); } ll mx = v[n - 1].X, second_mx = -1; for (int i = 1; i \u0026lt;= n; i++) { if (mxf[i] \u0026gt; second_mx \u0026amp;\u0026amp; mxf[i] \u0026lt; mx) second_mx = mxf[i]; } res = max(res, second_mx + mx); } else { res = v[n - 1].X + v[n - 2].X; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } /* CheckList: 1. long long 2. mod 3. template 4. input/output format/content 5. test sample input/output */ int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } D - Magical Cookies 死亡實作 @@，可以想像像題目那樣枚舉的話會是 $O(H^2W)$ 會 TLE，所以可以利用字元集很少這個特性來做，簡單來說就是先算好每行/列的每個字元有多少，然後每次就去看現在還沒被刪掉的有沒有字元是會整行/列都一樣的，就把他移掉，然後這個過程因為只有 $H + W$ 行+列，所以只會做到 $H + W$ 次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; void solve() { int h, w; cin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; w; vector\u0026lt;string\u0026gt; v(h); for (auto \u0026amp;s : v) cin \u0026gt;\u0026gt; s; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; cnth(26, vector\u0026lt;int\u0026gt;(h, 0)), cntw(26, vector\u0026lt;int\u0026gt;(w, 0)); for (int i = 0; i \u0026lt; h; i++) { for (int j = 0; j \u0026lt; w; j++) { int ind = v[i][j] - \u0026#39;a\u0026#39;; cnth[ind][i]++; cntw[ind][j]++; } } int resh = h, resw = w; vector\u0026lt;bool\u0026gt; skiph(h, false), skipw(w, false); for (int _ = 0; _ \u0026lt; h + w; _++) { vector\u0026lt;pii\u0026gt; ch, cw; for (int i = 0; i \u0026lt; h; i++) { if (skiph[i]) continue; for (int j = 0; j \u0026lt; 26; j++) { if (cnth[j][i] == resw \u0026amp;\u0026amp; resw \u0026gt;= 2) { ch.push_back({i, j}); } } } for (int i = 0; i \u0026lt; w; i++) { if (skipw[i]) continue; for (int j = 0; j \u0026lt; 26; j++) { if (cntw[j][i] == resh \u0026amp;\u0026amp; resh \u0026gt;= 2) { cw.push_back({i, j}); } } } for (auto p : ch) { skiph[p.X] = true; for (int i = 0; i \u0026lt; w; i++) cntw[p.Y][i]--; resh--; } for (auto p : cw) { skipw[p.X] = true; for (int i = 0; i \u0026lt; h; i++) cnth[p.Y][i]--; resw--; } } cout \u0026lt;\u0026lt; resh * resw \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } /* CheckList: 1. long long 2. mod 3. template 4. input/output format/content 5. test sample input/output */ int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } E - Prerequisites 乍看之下是簡單的拓墣排序，但是注意到他要求最小數量，所以有些根本不會在 DAG 裡的孤點我們就不管它，這時候就可以利用題目要求的是 read book 1，用一個 priority_queue 來代替平常拓墣排序用的 queue，這樣編號比較大的孤點在處理到有關 1 之前的 DAG 之前就會被先 pop 掉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; const int N = 2e5 + 5; vector\u0026lt;int\u0026gt; g[N]; int deg[N]; void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int c; cin \u0026gt;\u0026gt; c; for (int j = 0; j \u0026lt; c; j++) { int x; cin \u0026gt;\u0026gt; x; g[i].push_back(x); deg[x]++; } } priority_queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { if (deg[i] == 0) q.push(i); } vector\u0026lt;int\u0026gt; res; while (!q.empty()) { int u = q.top(); q.pop(); res.push_back(u); for (int v : g[u]) { --deg[v]; if (deg[v] == 0) q.push(v); } } for (int i = SZ(res) - 1; i \u0026gt;= 0; i--) { if (res[i] == 1) break; else cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } /* CheckList: 1. long long 2. mod 3. template 4. input/output format/content 5. test sample input/output */ int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } F - Shortcuts 待補。\n","permalink":"https://yun-20459.github.io/posts/atcoder-beginner-contest-315-%E9%A1%8C%E8%A7%A3/","tags":["Atcoder"],"title":"Atcoder Beginner Contest 315 題解"},{"contents":"A - Chord 判斷一下就好了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; string ss[7] = {\u0026#34;ACE\u0026#34;, \u0026#34;BDF\u0026#34;, \u0026#34;CEG\u0026#34;, \u0026#34;DFA\u0026#34;, \u0026#34;EGB\u0026#34;, \u0026#34;FAC\u0026#34;, \u0026#34;GBD\u0026#34;}; void solve() { string s; cin \u0026gt;\u0026gt; s; for (int i = 0; i \u0026lt; 7; i++) { if (s == ss[i]) { cout \u0026lt;\u0026lt; \u0026#34;Yes\\n\u0026#34;; return; } } cout \u0026lt;\u0026lt; \u0026#34;No\\n\u0026#34;; } /* CheckList: 1. long long 2. mod 3. template 4. input/output format/content 5. test sample input/output */ int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } B - TaK Code 可以直接手打出那個 pattern 然後比對一下就 ok\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; string pat[9] = { \u0026#34;###.?????\u0026#34;, \u0026#34;###.?????\u0026#34;, \u0026#34;###.?????\u0026#34;, \u0026#34;....?????\u0026#34;, \u0026#34;?????????\u0026#34;, \u0026#34;?????....\u0026#34;, \u0026#34;?????.###\u0026#34;, \u0026#34;?????.###\u0026#34;, \u0026#34;?????.###\u0026#34; }; void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;string\u0026gt; g(n); for (auto \u0026amp;s : g) cin \u0026gt;\u0026gt; s; for (int i = 0; i \u0026lt;= n - 9; i++) { for (int j = 0; j \u0026lt;= m - 9; j++) { bool ok = true; for (int dx = 0; dx \u0026lt; 9 \u0026amp;\u0026amp; ok; dx++) { for (int dy = 0; dy \u0026lt; 9 \u0026amp;\u0026amp; ok; dy++) { if (pat[dx][dy] != \u0026#39;?\u0026#39; \u0026amp;\u0026amp; g[i + dx][j + dy] != pat[dx][dy]) { ok = false; } } } if (ok) cout \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; j + 1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } } /* CheckList: 1. long long 2. mod 3. template 4. input/output format/content 5. test sample input/output */ int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } C - Invisible Hand 首先對 seller 跟 buyer 的錢 sort 不虧，然後可以發現這個錢是有單調性的，如果 x 元可以滿足的話那 x + 1 元一定可以，因為 seller 只會等於會變多，buyer 只會等於或變少，這樣 seller 一定 \u0026gt;= buyer。所以二分搜一下就好了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; seller(n), buyer(m); for (int \u0026amp;x : seller) cin \u0026gt;\u0026gt; x; for (int \u0026amp;x : buyer) cin \u0026gt;\u0026gt; x; sort(ALL(seller)); sort(ALL(buyer)); int l = 0, r = 1e9 + 1; auto chk = [\u0026amp;](int x) { int ind1 = upper_bound(ALL(seller), x) - seller.begin(); int ind2 = buyer.end() - lower_bound(ALL(buyer), x); return ind1 \u0026gt;= ind2; }; while (r - l \u0026gt; 1) { int m = (l + r) \u0026gt;\u0026gt; 1; if (chk(m)) r = m; else l = m; } cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } /* CheckList: 1. long long 2. mod 3. template 4. input/output format/content 5. test sample input/output */ int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } D - Count Bracket Sequences 看到 $2^x$ 又要 mod 998244353 就會先想到應該要 dp，然後合法匹配括號的話需要兩個條件\n左括號數量 = 右括號數量 任何前綴的左括號數量 \u0026gt;= 右括號數量 所以努力想一下就會有下面的 dp 式，$dp_{i, j} = $ 前 $i$ 個字元裡，左括號 - 右括號的數量 = $j$\n遞推式就像下面這樣\n$$\ndp_{i, j} =\n\\begin{cases}\ndp_{i - 1, j - 1} \u0026amp; \\quad \\text{if } s[i] = ( \\\\\ndp_{i - 1, j + 1} \u0026amp; \\quad \\text{if } s[i] = ) \\\\\ndp_{i - 1, j - 1} + dp_{i - 1, j + 1} \u0026amp; \\quad \\text{if } s[i] = ?\n\\end{cases}\n$$\nbase case: $dp_{0, 0} = 1$，求 $dp_{n, 0}$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; const int N = 3e3 + 5; const int M = 998244353; ll dp[N][N]; ll add(ll a, ll b) { return (a + b) % M; } void solve() { string s; cin \u0026gt;\u0026gt; s; int n = SZ(s); s = \u0026#34;@\u0026#34; + s; dp[0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= i; j++) { if (j == 0) { if (s[i] == \u0026#39;(\u0026#39;) continue; dp[i][j] = add(dp[i][j], dp[i - 1][j + 1]); } else { if (s[i] == \u0026#39;(\u0026#39;) dp[i][j] = add(dp[i][j], dp[i - 1][j - 1]); else if (s[i] == \u0026#39;)\u0026#39;) dp[i][j] = add(dp[i][j], dp[i - 1][j + 1]); else dp[i][j] = add(dp[i][j], add(dp[i - 1][j - 1], dp[i - 1][j + 1])); } } } cout \u0026lt;\u0026lt; dp[n][0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } /* CheckList: 1. long long 2. mod 3. template 4. input/output format/content 5. test sample input/output */ int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } E - Tangency of Cuboids 待補。\nF - Cans and Openers 首先對於所有的東西都 sort 一下不虧，畢竟都是要收益最大。再來可以再把三個東西歸成兩類，第一類是自己就可以開，第二類是互相依賴的關係，那最後我希望找到所有組合第一類取 $i$ 個，第二類取 $m - i$ 個，這樣我就可以 $O(m)$ 找出最大的那種組合。\n第一類因為可以自己開，所以 sort 之後前綴和就好。\n第二類的話可以用雙指針去慢慢爬，如果開罐器沒了就拿，如果開罐器還有就繼續開。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;ll\u0026gt; a, b, c; for (int i = 0; i \u0026lt; n; i++) { int t; ll x; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; x; if (t == 0) a.push_back(x); else if (t == 1) b.push_back(x); else c.push_back(x); } sort(ALL(a), greater\u0026lt;\u0026gt;()); sort(ALL(b), greater\u0026lt;\u0026gt;()); sort(ALL(c), greater\u0026lt;\u0026gt;()); vector\u0026lt;ll\u0026gt; x(m + 1, 0), y(m + 1, 0); for (int i = 1; i \u0026lt;= m; i++) { if (i - 1 \u0026lt; SZ(a)) x[i] = x[i - 1] + a[i - 1]; else x[i] = x[i - 1]; } int j = 0, use = 0, k = 0; for (int i = 1; i \u0026lt;= m; i++) { if (!use) { y[i] = y[i - 1]; use = (j == SZ(c) ? 0 : c[j++]); } else { y[i] = y[i - 1] + (k == SZ(b) ? 0 : b[k++]); use--; } } ll res = 0; for (int i = 0; i \u0026lt;= m; i++) res = max(res, x[i] + y[m - i]); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } /* CheckList: 1. long long 2. mod 3. template 4. input/output format/content 5. test sample input/output */ int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } G - Avoid Straight Line 待補。\n","permalink":"https://yun-20459.github.io/posts/atcoder-beginner-contest-312-%E9%A1%8C%E8%A7%A3/","tags":["Atcoder"],"title":"Atcoder Beginner Contest 312 題解"},{"contents":"A - To be Saikyo 直接找最大的是多少就好，注意要特判一下如果第一個就是最大的且沒有人跟他一樣大就不用加，不然還是要 +1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define pb emplace_back #define dbg(x) cout \u0026lt;\u0026lt; (#x \u0026#34; = \u0026#34;) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; void solve() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; p(n); for (int \u0026amp;x : p) cin \u0026gt;\u0026gt; x; int mx = *max_element(ALL(p)); if (mx == p[0]) { for (int i = 1; i \u0026lt; n; i++) { if (p[i] == mx) { cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return; } } cout \u0026lt;\u0026lt; \u0026#34;0\\n\u0026#34;; } else cout \u0026lt;\u0026lt; mx + 1 - p[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } B - Who is Saikyo? 這可以畫成一個有向圖，然後只有當入度為 0 的點只有一個的時候才判定得出最強的人。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define pb emplace_back #define dbg(x) cout \u0026lt;\u0026lt; (#x \u0026#34; = \u0026#34;) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; const int N = 50 + 5; int deg[N]; void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; deg[b]++; } vector\u0026lt;int\u0026gt; res; for (int i = 1; i \u0026lt;= n; i++) { if (deg[i] == 0) res.push_back(i); } if (SZ(res) == 1) cout \u0026lt;\u0026lt; res[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; } int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } C - Approximate Equalization 2 首先把 a 先排序一下一定不虧。最後的結果因為一定只能差 1，那麼平均分配給大家一定是最棒的，餘數就可以分給本來比較多的人，這樣操作次數就可以比較少。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cout \u0026lt;\u0026lt; (#x \u0026#34; = \u0026#34;) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; void solve() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n); ll sum = 0; for (int \u0026amp;x : a) { cin \u0026gt;\u0026gt; x; sum += x; } sort(ALL(a)); vector\u0026lt;int\u0026gt; b(n, sum / n); int r = sum % n; for (int i = n - 1; i \u0026gt; n - 1 - r; i--) b[i]++; ll res = 0; for (int i = 0; i \u0026lt; n; i++) res += abs(a[i] - b[i]); cout \u0026lt;\u0026lt; res / 2 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } D - Odd or Even 首先可以先把前 $k + 1$ 個弄成 $k$ 個式子，從這 $k$ 個式子中我們就可以先知道前 $k + 1$ 個數字的總和。例如說 $k = 3$ 的話就可以先問出下面這 3 條式子\n$$\n\\begin{align*}\nA_1 + A_2 + A_3 \u0026amp;= s_1 \\\\\nA_1 + A_2 + A_4 \u0026amp;= s_2 \\\\\nA_1 + A_3 + A_4 \u0026amp;= s_3 \\\\\nA_2 + A_3 + A_4 \u0026amp;= s_4 \\\\\n\\end{align*}\n$$\n因為注意到這些相加之後除以 $k + 1$ 在減掉每一條就可以得到 $A_1 ~ A_4$（這邊實作上用 xor，因為 xor 有很好的性質是 a xor a = 0），那麼剩下的要怎麼問到呢，既然我們都有了 $A_1 + A_2 + \u0026hellip; + A_{k - 1}$，那我們就可以帶著這些東西再一次配一個新東西去問就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cout \u0026lt;\u0026lt; (#x \u0026#34; = \u0026#34;) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; void out(vector\u0026lt;int\u0026gt; \u0026amp;v) { for (int x : v) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } void solve() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt; res(n); auto ask = [\u0026amp;](vector\u0026lt;int\u0026gt; v) { for (int \u0026amp;x : v) x++; cout \u0026lt;\u0026lt; \u0026#34;? \u0026#34;, out(v); int x; cin \u0026gt;\u0026gt; x; return x; }; int r = 0; for (int i = 0; i \u0026lt; k + 1; i++) { vector\u0026lt;int\u0026gt; v; for (int j = 0; j \u0026lt; k + 1; j++) { if (i != j) v.push_back(j); } res[i] = ask(v); r ^= res[i]; } for (int i = 0; i \u0026lt; k + 1; i++) res[i] ^= r; vector\u0026lt;int\u0026gt; v(k); int s = 0; for (int i = 0; i \u0026lt; k - 1; i++) v[i] = i, s ^= res[i]; for (int i = k + 1; i \u0026lt; n; i++) { v.back() = i; res[i] = s ^ (ask(v)); } cout \u0026lt;\u0026lt; \u0026#34;! \u0026#34;, out(res); } int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } E - Duplicate 首先可以觀察到\n觀察 1 如果有兩個相鄰的數字都 $\\geq 2$ 那麼就會沒完沒了，然後剩下的都有解。\n接下來\n觀察 2 只有一個方法可以讓數字遞減，那就是只由一個數字構成的後綴，這個東西會慢慢地不見 ex. 11111 當後綴之類的。\n觀察 3 如果有一串連續的 1 後面跟一個 char c，那麽這串東西等等就會變成遠本的 1 多加 $c - \u0026lsquo;1\u0026rsquo;$ 個 1。\n有這樣就可以做了，官解超級聰明直接用了一個 encode 方法，就是把連續的 char，是誰有幾個記錄下來，這樣從後面算回來就快很多（畢竟這題的觀察都是有關 suffix）\nencode 方法 example:\n223444445 -\u0026gt; {{2, 2}, {3, 1}, {4, 5}, {5, 1}}\n從後面算回來的方式是，如果當前的字元是 1，代表剛剛算過的東西會根據上一個字元 expand，所以就把當前的那個字元數有多少加上前面算過的東西 * 需要的次數，那如果當前的字元不是 1 的話，代表他等等才要被 expand，就先加 1，加 1 是因為我要去累計有多少人的等等要被 expand，可以模擬一下就會發現這樣加乘的過程中就是在累計 expand 數量。\n（我覺得我沒有解釋得很好 QQ）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; const int M = 998244353; vector\u0026lt;pair\u0026lt;char, ll\u0026gt;\u0026gt; encode(string \u0026amp;s) { if (SZ(s) == 0) return {}; char c = s[0]; int cnt = 1; vector\u0026lt;pair\u0026lt;char, ll\u0026gt;\u0026gt; v; for (int i = 1; s[i]; i++) { if (s[i] == c) cnt++; else { v.push_back({c, cnt * 1ll}); c = s[i]; cnt = 1; } } v.push_back({c, cnt}); return v; } ll add(ll a, ll b) { return (a + b) % M; } void solve() { int n; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; for (int i = 0; i \u0026lt; n - 1; i++) { if (s[i] \u0026gt;= \u0026#39;2\u0026#39; \u0026amp;\u0026amp; s[i + 1] \u0026gt;= \u0026#39;2\u0026#39;) { cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; return; } } vector\u0026lt;pair\u0026lt;char, ll\u0026gt;\u0026gt; v = encode(s); ll res = 0; char last = \u0026#39;1\u0026#39;; while (!v.empty()) { auto [c, cnt] = v.back(); v.pop_back(); if (c == \u0026#39;1\u0026#39;) { cnt = add(cnt, res * (last - \u0026#39;1\u0026#39;)); res = add(res, cnt); } else { res = add(res, 1); } last = c; } cout \u0026lt;\u0026lt; (res - 1 + M) % M; } /* CheckList: 1. long long 2. mod 3. template 4. input/output format/content 5. test sample input/output */ int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } ","permalink":"https://yun-20459.github.io/posts/atcoder-beginner-contest-313-%E9%A1%8C%E8%A7%A3/","tags":["Atcoder"],"title":"Atcoder Beginner Contest 313 題解"},{"contents":"A - 3.14 直接複製一下題目然後輸出就好了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; string pi = \u0026#34;3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\u0026#34;; void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n + 2; i++) cout \u0026lt;\u0026lt; pi[i]; } /* CheckList: 1. long long 2. mod 3. template 4. input/output format/content 5. test sample input/output */ int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } B - Roulette 因為需要知道每個 [0, 36] 的輪盤有誰 bet，然後那個人 bet 了幾個，然後我懶得 sort 所以直接開 set （寫完後才意識到他其實只要看一個數字而已，所以 vector 存，最後再拿它出來 sort 就好），這樣他就幫我排序按照 bet 了幾個排序好了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; set\u0026lt;pii\u0026gt; cnt[37]; void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int c; cin \u0026gt;\u0026gt; c; for (int j = 0; j \u0026lt; c; j++) { int a; cin \u0026gt;\u0026gt; a; cnt[a].insert({c, i}); } } int x; cin \u0026gt;\u0026gt; x; int betmn = cnt[x].begin()-\u0026gt;X; vector\u0026lt;int\u0026gt; res; for (auto it = cnt[x].begin(); it != cnt[x].end(); it++) { if (it-\u0026gt;X == betmn) { res.push_back(it-\u0026gt;Y); } else { break; } } cout \u0026lt;\u0026lt; SZ(res) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; for (int r : res) cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } /* CheckList: 1. long long 2. mod 3. template 4. input/output format/content 5. test sample input/output */ int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } C - Rotated Color Subsequence 因為對於每個顏色 [1, m] 就是往右移一個，所以可以直接把他們按照顏色存起來，然後按照原本的顏色順序從每一個顏色的最後一個開始輸出就好\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; string s; cin \u0026gt;\u0026gt; s; vector\u0026lt;int\u0026gt; c(n); vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; v(m + 1); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; c[i]; v[c[i]].push_back(s[i]); } vector\u0026lt;int\u0026gt; ptrs(m + 1, 0); for (int i = 1; i \u0026lt;= m; i++) { ptrs[i] = SZ(v[i]) - 1; } for (int i = 0; i \u0026lt; n; i++) { cout \u0026lt;\u0026lt; v[c[i]][ptrs[c[i]]]; ptrs[c[i]] = (ptrs[c[i]] + 1) % SZ(v[c[i]]); } } /* CheckList: 1. long long 2. mod 3. template 4. input/output format/content 5. test sample input/output */ int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } D - LOWER 對於所有在變成 upper/lower 之前的操作都只能算是改動字元，大小寫會被 upper/lower 的操作覆蓋掉。 upper/lower 的操作也會互相覆蓋，所以只要知道最後一個 upper/lower 的操作，然後把在他之前的改動字元改一下，然後全部變成 upper/lower，操作次序在這個「最後一個 upper/lower」後面的改動字元操作才會真的是那個字元，再拿出來改就好了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; struct OP { int op_id, ind; char c; OP(int x = 0, int y = 0, char ch = \u0026#39;$\u0026#39;) : op_id(x), ind(y), c(ch) {}; }; void solve() { int n; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; int q; cin \u0026gt;\u0026gt; q; int cnt = 0, last = -1; bool flag = 0; vector\u0026lt;OP\u0026gt; ops; for (int i = 1; i \u0026lt;= q; i++) { int op, ind; char c; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; ind \u0026gt;\u0026gt; c; if (op == 1) { ind--; ops.push_back(OP(i, ind, c)); } else if (op == 2) { flag = 1; cnt = 1; last = i; } else { flag = 1; cnt = 0; last = i; } } if (flag) { for (auto [op_id, ind, c] : ops) { if (op_id \u0026gt; last) break; s[ind] = c; } if (cnt) { // to lower for (int i = 0; i \u0026lt; n; i++) s[i] = tolower(s[i]); } else { for (int i = 0; i \u0026lt; n; i++) s[i] = toupper(s[i]); } } for (auto [op_id, ind, c] : ops) { if (op_id \u0026gt; last) s[ind] = c; } cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } /* CheckList: 1. long long 2. mod 3. template 4. input/output format/content 5. test sample input/output */ int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } E - Roulettes 對於 [1, m] 的點數我們可以去想說他從哪個輪盤轉移會最好，例如說一個輪盤有 1, 4, 6, 8, 這四個數字，那麼 $dp[i]$ 就可以從 $dp[i - 1], dp[i - 4], dp[i - 6], dp[i - 8] + c[j]$, where j = 輪盤編號。但是注意到這樣如果輪盤上存在 0 這個數字，那麽 $dp[i]$ 遞迴的時候就會錯。那要怎麼處理呢？\n假設有 0, 4, 6, 8 這四個數字，列式原本會長這樣\n$$dp[cost] = c_i + \\frac{1}{4}dp[cost] + \\frac{1}{4}dp[cost - 4] + \\frac{1}{4}dp[cost - 6] + \\frac{1}{4}dp[cost - 8]$$\n移項之後就變成\n$$\\frac{3}{4}dp[cost] = c_i + \\frac{1}{4}dp[cost - 4] + \\frac{1}{4}dp[cost - 6] + \\frac{1}{4}dp[cost - 8]$$\n就再變成\n$$dp[cost] = \\frac{4}{3}c_i + \\frac{1}{3}dp[cost - 4] + \\frac{1}{3}dp[cost - 6] + \\frac{1}{3}dp[cost - 8] $$\n所以對於每個輪盤有 $p_i$ 個數字，其中有 $z$ 個 0 的話，$dp[cost]$ 其實會長成這樣\n$$dp[cost] = \\frac{p_i}{p_i - z}c_i + \\frac{1}{p_i - z} \\sum_{j = 1}^{p_i} dp[max(0, cost - s_{i, j})]$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; const int N = 100 + 5; const double inf = 1e18; int c[N], p[N], s[N][N]; double dp[N]; void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; c[i] \u0026gt;\u0026gt; p[i]; for (int j = 1; j \u0026lt;= p[i]; j++) { cin \u0026gt;\u0026gt; s[i][j]; } } for (int cost = 1; cost \u0026lt;= m; cost++) { dp[cost] = inf; for (int i = 1; i \u0026lt;= n; i++) { double d = 0; int z = 0; for (int j = 1; j \u0026lt;= p[i]; j++) { if (s[i][j] == 0) z++; else d += dp[max(0, cost - s[i][j])]; } d += (double)c[i] * p[i]; d /= (double)(p[i] - z); dp[cost] = min(dp[cost], d); } } cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(15) \u0026lt;\u0026lt; dp[m] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } /* CheckList: 1. long long 2. mod 3. template 4. input/output format/content 5. test sample input/output */ int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } F - A Certain Game 可以參考題解的這張圖\n我們可以用一個 dsu 來紀錄誰跟誰一組，那你會注意到 dsu 需要多開 $n - 1$ 個點來當比賽結果，然後把這些都弄成一棵樹，接下來從根開始 dfs，每次都把邊權下推，推到 [1, n] 的節點就是答案。\n這邊要注意的實作細節是我的 dsu 寫法有 union by size，但是在這裡是不對的，我希望他要是特定的人當 father (aka 比賽結果)，所以不能 union by size。 debug 了好久 QQ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #define dbg(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; const int M = 998244353; struct DJS { int n; vector\u0026lt;int\u0026gt; p, sz; DJS(int _n) : n(_n) { p.resize(n); iota(ALL(p), 0); sz.assign(n, 1); } int find(int x) { return p[x] == x ? x : p[x] = find(p[x]); } void merge(int x, int y) { x = find(x), y = find(y); if (x == y) return; sz[y] += sz[x]; p[x] = y; } }; int pw(int a, int b) { int r = 1; while (b) { if (b \u0026amp; 1) r = 1ll * r * a % M; a = 1ll * a * a % M; b \u0026gt;\u0026gt;= 1; } return r; } int inv(int x){ return pw(x, M - 2) % M; } int mul(int x, int y) { return 1ll * x * y % M; } const int N = 5e5 + 10; vector\u0026lt;pii\u0026gt; g[N]; void solve() { int n; cin \u0026gt;\u0026gt; n; DJS djs(2 * n + 10); for (int i = n + 1; i \u0026lt;= 2 * n; i++) djs.sz[i] = 0; int ind = n; for (int i = 1; i \u0026lt; n; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; ind++; int pu = djs.find(u), pv = djs.find(v); int szu = djs.sz[pu], szv = djs.sz[pv]; int tot = inv(szu + szv); g[ind].push_back({pu, mul(szu, tot)}); g[ind].push_back({pv, mul(szv, tot)}); djs.merge(u, ind); djs.merge(v, ind); } vector\u0026lt;int\u0026gt; res(n + 1); function\u0026lt;void(int, int)\u0026gt; dfs = [\u0026amp;](int u, int p) { if (u \u0026lt;= n) { res[u] = p; return; } for (auto [v, w] : g[u]) { //cerr \u0026lt;\u0026lt; \u0026#34;u = \u0026#34; \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0026#34;, v = \u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;, w = \u0026#34; \u0026lt;\u0026lt; w \u0026lt;\u0026lt; endl; dfs(v, (p + w) % M); } }; dfs(ind, 0); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i == n]; } /* CheckList: 1. long long 2. mod 3. template 4. input/output format/content 5. test sample input/output */ int main() { ios::sync_with_stdio(0);cin.tie(0); int T = 1; // cin \u0026gt;\u0026gt; T; while (T--) solve(); return 0; } 小 os 試著補完每一週的 ABC，其實蠻想打的但是週六培訓班完回家就死在地上ㄌ，所以盡量補 \u0026gt;\u0026lt; 可能也不會一次打完會慢慢更新，希望可以維持，加油！\u0026gt;\u0026lt;\n","permalink":"https://yun-20459.github.io/posts/atcoder-beginner-contest-314-%E9%A1%8C%E8%A7%A3/","tags":["Atcoder"],"title":"Atcoder Beginner Contest 314 題解"},{"contents":"上次團練的時候被學長建議了這種寫法，所以記錄一下。以往我都是寫\n1 2 3 4 5 while (l \u0026lt; r) { int m = (l + r) \u0026gt;\u0026gt; 1; if (chk(m)) r = m; else l = m + 1; } 但有時候就會搞不清楚自己到底想要取什麼 = =，有點笨，所以換成下面的寫法\n1 2 3 4 5 while (r - l \u0026gt; 1) { int m = (l + r) \u0026gt;\u0026gt; 1; if (chk(m)) l = m; else r = m; } 這樣的寫法可以解釋成，如果 check mid 是對的，那麼我就提升左界，找到符合資格最大的，不然就下壓右界，然後因為停止條件是 $r - l == 1$，所以到時候 $l$ 就是合法的最大界，$r$ 會是不合法的最小界。\n","permalink":"https://yun-20459.github.io/posts/%E4%BA%8C%E5%88%86%E6%90%9C%E6%8A%80%E5%B7%A7/","tags":["binary search"],"title":"二分搜技巧"},{"contents":"修的課程 資訊系必修：人工智慧導論、計算機網路實驗\n資訊系選修：數位視覺效果、巨量資料系統之應用\n通識：森林醫學點線面\n人工智慧導論 開課教授：陳尚澤、陳縕儂\n涼度：4.5/5 (扣在期末 project 上)\n甜度：5/5\n前半學期是 UC Berkeley 的 CS188，後半學期是軒田 ML style + 縕儂擅長的 DL。整體來說作業都可以做得很快，應該三個小時可以做完，期中考的話可以多做 CS188 的考古題，今年的幾乎全部都是從這裡出的，沒有期末考只有機率大賽的期末 project 德州撲克AI，助教會給閹割版的 pypokerengine 然後說我們不能抄= = ?，真的會氣死，不過也有可能是我很爛，還是有同學拿到滿分，真的很厲害\n計算機網路實驗 開課教授：張傑帆\n涼度：4/5\n甜度：5/5\n基本上跟隔壁班上課內容是一模一樣的，不過不知道期末 project 規範一不一樣。這班的投影片錯誤百出，不可能按照投影片做出來，需要自己花時間 google。報告評分標準是把所有組別排名之後給分，所以就算你寫的不錯只要大家寫的比你好就下去。期末 project 教授跟我們這組說要有網站 + ML，結果最後成果只有我們這組有 ML :D 總之我覺得會修到蠻生氣的，脾氣不好的人不要修這一班，但是教授會調很多分啦。\n數位視覺效果 開課教授：莊永裕\n涼度：2/5\n甜度：4/5\n做多少事拿多少分，不過要做的事蠻多的，第一個作業主要會是在實作論文的演算法，第二個的話會是寫抓取 feature 的演算法上比較困難，想要多拿分數的就要多實作這樣，每一個作業也都有投票，前五名有加分（賺，謝謝我的攝影大腿隊友），要注意的是助教送出去的不是最後成績，老師會再自己評分 Final project + 調分（有可能是往下調\u0026hellip;）不過整體而言推這門課，學到蠻多基礎知識的。\n巨量資料系統之應用 開課教授：廖世偉\n涼度：5/5\n甜度：5/5\n傳說中阿公的朋友的兒子的課(X)，主要就是玩 GPT 跟聽演講(?)，期中期末開書考所以看一下就好，Final Project 比較有趣可以多分析 GPT-3.5 跟 GPT-4 的差別\n森林醫學點線面 開課教授：蘇大成\n涼度：5/5\n甜度：5/5\n有趣又可以學到東西的通識課，每次上課都會點名+小考，但是小考上課有聽就一定會完全不用擔心，期末報告分數也是給得很好。印象最深刻是老師帶了台大實驗林做的精油來，真的是聞起來很\u0026hellip;舒\u0026hellip;.服\u0026hellip;.所以當天就跑去森林周買了一小罐忘記什麼樹的精油了，總之好讚 \u0026gt;\u0026lt; 上課真的會介紹很多森林知識，喜歡森林如我聽得非常開心，不喜歡的話就默默地做自己的事情看起來也沒怎樣\n感想區 這學期主要還有在做的事就是在 Appworks 實習，所以學分才會這麼少。你說怎麼沒有在結訓照片看到我？那肯定是因為我退訓了阿，不過是最後三周才退訓的，所以學分也沒有因此變多。\n整體來說這學期常常心很累，一下被教授雷，一下被助教雷，成績雖然不錯但名次還是繼續下去探親，希望下學期可以改善，還有 ICPC 加油 \u0026gt;\u0026lt; 現在每天都有在練習題目，應該可以進桃園站的吧 \u0026gt;\u0026lt;\n","permalink":"https://yun-20459.github.io/posts/111-2-%E4%BF%AE%E8%AA%B2%E5%BF%83%E5%BE%97/","tags":["class"],"title":"111-2 修課心得"},{"contents":"之前在 appworks 的時候直接用了朋友推薦的這個 docker image，直接把 nginx 跟 certbot 打包好給你，只要寫少少的 .conf 就可以了。不過這次在寫 CNL 的期末專案的時候，組員寫的 html 會掛在外面，要弄成 docker 有點麻煩（其實就是我懶得請人家弄），所以就直接在 EC2 上面弄 nginx + certbot 了，記錄一下免得之後忘記。\n環境：AWS EC2 instance(Ubuntu 22.04)\n安裝 nginx 1 2 3 sudo apt update sudo wget http://nginx.org/keys/nginx_signing.key sudo apt-key add nginx_signing.key 1 2 3 sudo apt update sudo apt install nginx sudo systemctl start nginx.service 到這裡就已經開好 nginx 服務了，可以用\n1 sudo systemctl status nginx.service 確認有沒有在跑\n安裝 certbot 1 2 sudo apt-get update -y sudo apt-get install certbot python3-certbot-nginx -y 申請憑證\n1 sudo certbot --nginx --email \u0026lt;你的email\u0026gt; --agree-tos -d \u0026lt;你的域名\u0026gt; 申請成功後，憑證會被放在/etc/letsencrypt/live/\u0026lt;你的域名\u0026gt;，certbot 也會幫你改好你的 nginx.conf 或者 nginx/sites-available/default，這時候連上去自己的域名應該就可以用 https 了\n","permalink":"https://yun-20459.github.io/posts/nginx-certbot-%E7%B4%80%E9%8C%84/","tags":["nginx","certbot"],"title":"nginx \u0026 certbot 紀錄"},{"contents":"修的課程 資訊系必修：系統程式設計、專題研究、計算機網路\n資訊系選修：數位聲音藝術與創作\n通識：海洋科學概論\n系統程式設計 開課教授：鄭卜壬\n涼度：5/5\n甜度：3/5\n靠著前人的筆記活下來了 \u0026gt;\u0026lt; 主要還是程式作業太雷了，該測的 case 都沒有測好，不然應該算甜（？）這門課主要是要跟上老師的速度蠻困難的，雖然恢復實體之後老師的笑話也變多了，整個上課步調變得輕鬆一點點，只是 16 周要上完 18 周的進度導致變出了很多影片要我們自己看 QQ 建議上課的時候可以錄個音或者像我們這屆有去年的影片可以看，多聽幾遍，魔鬼都在細節中，考試一定考\n專題研究 開課教授：陳彥仰\n涼度：4/5\n甜度：2/5\n就是加 lab，我跟到的 project 剛好發了一篇論文就蹭到了第 n 作 \u0026gt;\u0026lt; 人機互動真的不錯玩，雖然 VR 真的好暈好暈，甜度的部分給 2 是因為我覺得我在暑假做了蠻多事的（因為開學就要投論文，所以暑假比較忙，所以涼度給 4 分主要是開學比較沒那麼忙）結果成績慘慘 \u0026gt;\u0026lt;\n計算機網路 開課教授：周承復\n涼度：5/5\n甜度：5/5\n隨便查評價都知道有多甜涼（？）憑心而論老師上的不錯，期末的 project 也很好玩，可以學到很多酷東西，作業的話網路上都有解答不過還是建議自己想一次，畢竟考試就幾乎一樣的東西，然後老師都會給去年的考古題 + 答案，有夠佛心 \u0026gt;\u0026lt;（雖然不會考w\n數位聲音藝術與創作 開課教授：林經堯\n涼度：3/5\n甜度：3/5\n有趣的課程，在 ptt 上看到評價就決定選了，開學老師就有說他等第就是靠感覺給，所以甜度給 3 顆 \u0026gt;\u0026lt; （老師有說會在 A 字頭）教 pure data 跟 p5.js，對生成藝術 + 音樂有興趣的應該會覺得很好玩，偷偷抱怨一下助教很雷所以上課有時候品質不是很好 QQ 但整體來說整學期收穫超級多，有學到很多酷東西，雖然我們的作品不能作成 NFT 有點小可惜，不過真心好玩 \u0026gt;\u0026lt; （我甚至用 p5.js 寫了 FFT \u0026gt;\u0026lt;\n海洋科學概論 開課教授：合授\n涼度：4/5\n甜度：3/5\n就是通識課w 很多人都覺得很甜涼但我覺得普通甜，可能是我太爛了 QQ 雖然滿分有 110 但是考試根本難，那些東西真的有出現在 ppt 上面嗎 QQ\n感想區 其實我差點忘了要打修課心得w\n這學期還當了 ADA 助教，很快樂的在期中期末蹭吃蹭喝 \u0026gt;\u0026lt; TA Hour 也只要負責程式題，快樂 \u0026gt;\u0026lt; （感謝好朋友罩我手寫）然後還有 icpc 培訓班，不過 icpc 培訓班我沒有選學分就沒歸在修的課程裡了w 就是每週團練 + 一坨功課，這學期很可惜的 topc 沒有打好，明年就繼續加油吧 \u0026gt;\u0026lt;\n","permalink":"https://yun-20459.github.io/posts/111-1-%E4%BF%AE%E8%AA%B2%E5%BF%83%E5%BE%97/","tags":["class"],"title":"111-1 修課心得"},{"contents":"這題好難，我看了好多遍別人的題解才懂 QwQ\n題目 給一個陣列，考慮一個無限的集合 $S$ 由符合以下條件之一的 $x$ 構成\n$x = a[i]$ $x = 2 * y + 1$ and $y \\in S$ $x = 4 * y$ and $y \\in S$ 問在集合 $S$ 中有多少元素小於 $2^p$，答案很大要 mod $1e9+7$\n作法 因為 $p$ 的範圍會到 2e5，所以要用二進制來想這題。\n對於一個二進位制為 $t$ 的數字，可以想像操作二就是左移一位然後末位補 1，操作二就是左移兩位（這邊就有點像 string）。所以可以觀察出一個結論，就是對於一個數字，把它增加 $i$ 位的方法有 $dp_i$ 種，這裡的 $dp$ 就是費波那契數列。\n那這跟答案有什麼關係呢，假設一個二進位制為 $t$ 的數字存在在 $a$ 之中，那麼他擴展出的數字要小於 $p$ 的話，他擴展出的數字的數量就會是 $\\sum_{i = 0}^{p - t} dp_i$，也就是不擴展、擴展一位、擴展兩位\u0026hellip;，那這件事情可以透過在算費波那契數列的時候算前綴和得到。\n接下來考慮是不是每個 $a[i]$ 都會對答案有貢獻，其實不是這樣，因為 $S$ 是一個 set，不會有重複的數字出現，所以如果會重複出現就不用算。那題解的做法是說那就把會產生的數字想成一棵樹，我一直去看產生 $x$ 的 parent 有沒有已經被 create 過，如果有的話，那就代表 $x$ 已經被前面的數字（也就是 parent） create 過了，那就不能算進答案裡面（因為已經算過了），在這邊的話 parent 的意思就是說看他能不能逆推操作二或操作三。\n詳細實作就看 code，我一直想說為什麼大家都要用 map 記不用 set，寫起來才發現這樣 code 會好寫一點。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define endl \u0026#39;\\n\u0026#39; #define X first #define Y second const int mod = 1e9 + 7; const int mxn = 2e5 + 5; int a[mxn]; ll pre[mxn], dp[mxn]; ll ans; void init() { dp[0] = dp[1] = 1; pre[0] = 1, pre[1] = 2; for (int i = 2; i \u0026lt; mxn; i++) { dp[i] = (dp[i - 1] + dp[i - 2]) % mod; pre[i] = (pre[i - 1] + dp[i]) % mod; } } void solve() { int n, p; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p; init(); set\u0026lt;int\u0026gt; st; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; st.insert(a[i]); } for (int i = 0; i \u0026lt; n; i++) { int flag = 0, x = a[i]; while (x) { if (x % 2) x \u0026gt;\u0026gt;= 1; else if (x % 4 == 0) x \u0026gt;\u0026gt;= 2; else break; if (st.find(x) != st.end()) { flag = 1; break; } } if (flag) continue; int len = __lg(a[i]) + 1; if (p - len \u0026gt;= 0) { ans = (ans + pre[p - len]) % mod; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0);cin.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) { solve(); } return 0; } ","permalink":"https://yun-20459.github.io/posts/codeforces-1635d-infinite-set/","tags":["Codeforces","bitmask","dp","number theory","string"],"title":"Codeforces 1635D. Infinite Set"},{"contents":"定義 給一個無向連通圖，去掉一個邊集合之後可以使得圖變成兩個連通分量，這個邊集合就叫做割集。\n最小割的意思就是找到一個權重和最小的割集。\nStoer Wagner 演算法 我不會證明，所以直接講求最小割的演算法。（ps. 如果有人會的話可以教我 \u0026gt;\u0026lt;）\n1 2 3 4 5 全局最小值為 INT_MAX 做 n - 1 次「合併」下面的 3 點直到整個圖變成整個連通 1. 固定點 s 用 prim 做最大生成樹，並記錄最後擴展的兩個點（也可以想成是最後的點+最後的邊） 2. 如果跟最後擴展的點連接的所有邊權和 \u0026lt; 全局最小值就更新 3. 合併最後擴展的那兩個頂點為一個點（我的做法是直接合併邊） 模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 struct SW_Min_Cut { static const int maxn = 500 + 5; int edge[maxn][maxn]; int n; int vis[maxn], del[maxn], weight[maxn]; void Init(int _n) { memset(edge, 0, sizeof(edge)); memset(del, 0, sizeof(del)); n = _n; } void AddEdge(int u, int v, int w) { edge[u][v] += w; edge[v][u] += w; } void Search(int \u0026amp;s, int \u0026amp;t) { memset(vis, 0, sizeof(vis)); memset(weight, 0, sizeof(weight)); s = t = -1; while (true) { int mx = -1, cur = 0; for (int i = 0; i \u0026lt; n; i++) { if (!del[i] \u0026amp;\u0026amp; !vis[i] and mx \u0026lt; weight[i]) { cur = i, mx = weight[i]; } } if (mx == -1) break; vis[cur] = 1; s = t, t = cur; for (int i = 0; i \u0026lt; n; i++) { if (!vis[i] \u0026amp;\u0026amp; !del[i]) weight[i] += edge[cur][i]; } } } int Solve() { int res = INT_MAX; for (int i = 0, x, y; i \u0026lt; n - 1; i++) { Search(x, y); res = min(res, weight[y]); del[y] = 1; for (int j = 0; j \u0026lt; n; j++) { edge[x][j] = (edge[j][x] += edge[y][j]); } } return res; } } graph; ","permalink":"https://yun-20459.github.io/posts/stoer-wagner-min-cut-%E6%BC%94%E7%AE%97%E6%B3%95/","tags":["flow"],"title":"Stoer Wagner Min Cut 演算法"},{"contents":"題目 link\n作法 是單調隊列的經典題目，只是這題變成要往左往右看，看到第一個比它小的就停止，這樣就會知道以它的高度設置螢幕的話最寬能夠到多少。這邊用 vector 實作 stack 比較好寫（我看了別人的 code 覺得好棒），只是我不太習慣它 stack 的寫法，所以把 stack 存的值改成 {value, id} 這樣。\n然後記得要開 long long ，我 WA 了好多次 QQ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define int ll #define SZ(a) (int)(a).size() #define endl \u0026#39;\\n\u0026#39; #define X first #define Y second const int mxn = 2e5 + 5; int a[mxn], lhs[mxn], rhs[mxn], ans[mxn]; void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; vector\u0026lt;pll\u0026gt; stk(1, {0ll, 0ll}); // store {value, id} for (int i = 1; i \u0026lt;= n; i++) { while (a[i] \u0026lt;= stk.back().X) stk.pop_back(); lhs[i] = i - stk.back().Y; stk.push_back({a[i], i}); } while (!stk.empty()) stk.pop_back(); stk.push_back({0, n + 1}); for (int i = n; i \u0026gt;= 1; i--) { while (a[i] \u0026lt;= stk.back().X) stk.pop_back(); rhs[i] = stk.back().Y - i - 1; stk.push_back({a[i], i}); } for (int i = 1; i \u0026lt;= n; i++) { ans[i] = a[i] * (lhs[i] + rhs[i]); } cout \u0026lt;\u0026lt; *max_element(ans + 1, ans + n + 1) \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0);cin.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) { solve(); } return 0; } ","permalink":"https://yun-20459.github.io/posts/neoj-513-%E8%B6%85%E5%A4%A7%E8%9E%A2%E5%B9%95%E8%A8%AD%E7%BD%AE/","tags":["NEOJ","monotonic stack"],"title":"NEOJ 513 超大螢幕設置"},{"contents":"題目 給 $n$ 個圍成一圈的小孩，每 2 個人就移掉 2 個人中的第二個，問第 $k$ 個小孩被移掉的編號\n作法 這題網路上有很多題解，我看的懂 tutorial 但實作都看不懂所以寫一下。 ps 是我隊友教我的她好棒\n因為圍成一圈，所以說我們可以把要移掉的數目看成是 $\\frac{n + 1}{2}$，這樣一來如果 $n$ 是奇數，被移掉的就會是所有的偶數跟 1，反之則是移掉所有的偶數。\n那麼遞迴下去做的話，可以看成是把該移掉的人移掉之後重新編號成 1, 2, 3, \u0026hellip;，再把 index remap 回來，所以這時候就要看原本是奇數還是偶數來決定怎麼 remap。\n舉例來說，如果 $n$ 是奇數，那第一輪拿完會變成 3, 5, 7, \u0026hellip;, n，這樣重新編號成 1, 2, 3, \u0026hellip;，就要 $2 \\times \\text{id} + 1$ remap 回來。如果 $n$ 是偶數的話，那第一輪拿完會變成 1, 3, 5, 7, \u0026hellip;, n，這樣重新編號成 1, 2, 3, \u0026hellip;，就要 $2 \\times \\text{id} - 1$ remap 回來。\n希望這樣舉例解釋會比較好懂 remap 的部分 QQ （我就是卡在這裡\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define SZ(a) (int)(a).size() #define endl \u0026#39;\\n\u0026#39; #define X first #define Y second int f(int n, int k) { if (n == 1) return 1; int kill = (n + 1) / 2; if (k \u0026lt;= kill) { if (2 * k \u0026gt; n) return 2 * k % n; return 2 * k; } int tmp = f(n \u0026gt;\u0026gt; 1, k - kill); if (n \u0026amp; 1) return 2 * tmp + 1; return 2 * tmp - 1; } void solve() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; cout \u0026lt;\u0026lt; f(n, k) \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0);cin.tie(0); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) { solve(); } return 0; } ","permalink":"https://yun-20459.github.io/posts/cses-josephus-queries/","tags":["CSES","math"],"title":"CSES Josephus Queries"},{"contents":"第一次接觸樹 dp OuO\n題目 給一棵樹，找到最大的邊集合使得任兩邊不共享一個點，輸出集合大小。\n作法 定義 如果是 array 版本的話（i.e. 給一個序列不能選相鄰的，最大化價值），比較容易可以想到轉移式 $dp(i) = max(v_i + dp(i - 2), dp(i - 1))$\n轉成樹的版本的話，就需要在樹上面做 dp，對於一個節點 $u$ 有下面兩種情況\n取一條跟 $v \\in child(u)$ 有連接的邊，答案定義為 $dp_0(u)$ 不取任何跟 $v \\in child(u)$ 有連接的邊，答案定義為 $dp_1(u)$ 為什麼沒有取兩條以上的 case 呢？因為如果取兩條以上的話 $u$ 就會變成那個共享的點。\n所以從上面的定義可以知道答案是 $max(dp_0(1), dp_1(1))$\n轉移式 $dp_1(u)$\n因為不取任何跟 $v \\in child(u)$ 有連接的邊，所以不管「跟 $v$ 的小孩有連接的邊」取不取都可以，所以答案就是\n$dp_1(u) = \\sum_{v \\in child(u)} max(dp_0(v), dp_1(v))$\n$dp_0(u)$\n可以先處理取一條的部分，因為取了 $u \\rightarrow v$ 這一條，所以「不取任何跟 $w \\in child(v)$ 有連接的邊」是 $dp_1(v)$，再加上 $u \\rightarrow v$ 這一條，就是 $dp_1(v) + 1$。\n接下來要加上 $w \\in child(u), w \\neq v$ 的部分，畫一下圖就會發現就是\n$\\sum_{w \\in child(u), w \\neq v} max(dp_0(w), dp_1(w))$\n那這個東西其實前面算過了，就是 $dp_1(u) - max(dp_0(v), dp_1(v))$\n所以綜合起來就是\n$dp_0(u) = dp_1(v) + 1 + dp_1(u) - max(dp_0(v), dp_1(v))$\ncode 要注意 $dp_0(u)$ 會用到 $dp_1(u)$ 的結果，所以要先算 $dp_1(u)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; const int mxn = 2e5 + 5; int dp[mxn][2]; vector\u0026lt;int\u0026gt; g[mxn]; void dfs(int u, int p) { for (int v : g[u]) { if (v != p) { dfs(v, u); dp[u][1] += max(dp[v][0], dp[v][1]); } } for (int v : g[u]) { if (v != p) { dp[u][0] = max(dp[u][0], dp[v][1] + 1 + dp[u][1] - max(dp[v][0], dp[v][1])); } } } void solve() { #define eb emplace_back int n; cin \u0026gt;\u0026gt; n; for (int i = 0, x, y; i \u0026lt; n - 1; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; g[x].eb(y); g[y].eb(x); } dfs(1, 0); cout \u0026lt;\u0026lt; max(dp[1][0], dp[1][1]) \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0);cin.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) { solve(); } return 0; } ","permalink":"https://yun-20459.github.io/posts/cses-tree-matching/","tags":["CSES","dp","tree"],"title":"CSES Tree Matching"},{"contents":"題目 給定一個長度為 $n$ 的序列 $a$，給 $n$ 個詢問，對於每個詢問 $pos$，輸出位置為 $pos$ 的值並從序列中刪除。\n作法 這題的技巧要用到「BIT 上二分搜」，可以想像如果一個數字還沒有被刪除，我們就將它的 presentation 記為 $1$，反之則為 $0$，那麼查詢位置在 $pos$ 的元素等於就是查找前綴和為 $pos$，且 presentation = 1 的位置。\n至於二分搜要怎麼實作呢，BIT 的節點是根據 2 的冪次劃分的，所以每次可以嘗試擴展 2 的冪次，看現在的前綴和是不是小於詢問，如果是的話代表可以擴展。等於說我們在找 $\\sum_{i = 1}^x presentation[i] \u0026lt; pos$ 的 $x$，如果現在的和還比詢問小的話就可以擴展。所以一路這樣擴展下去之後，我們會找到最大的 $x$ 符合上式，那麼 $x + 1$ 就是答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; const int mxn = 2e5 + 5; int n, a[mxn]; int bits(int x) { // floor(log2(x)) return x == 0 ? 0 : 31 - __builtin_clz(x); } struct BIT { int bit[mxn]; int lowbit(int x) { return x \u0026amp; (-x); } void update(int pos, int val) { for (int i = pos; i \u0026lt;= n; i += lowbit(i)) bit[i] += val; } int query(int x) { int p = 0; for (int i = 1 \u0026lt;\u0026lt; bits(n); i; i \u0026gt;\u0026gt;= 1) { if (p + i \u0026lt;= n \u0026amp;\u0026amp; bit[p + i] \u0026lt; x) { x -= bit[p += i]; } } return p + 1; } } bit; void solve() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; bit.update(i, 1); } int p; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; p; int res = bit.query(p); cout \u0026lt;\u0026lt; a[res] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; bit.update(res, -1); } } int main() { ios::sync_with_stdio(0);cin.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) { solve(); } return 0; } ","permalink":"https://yun-20459.github.io/posts/cses-list-removals/","tags":["CSES","BIT"],"title":"CSES List Removals"},{"contents":"題目 給一個序列 $a$，對於每個詢問 $x$ 找到最小的 $i$ 使得 $a[i] \u0026gt;= x$，並將 $a[i] -= x$。\n作法 這題要用到的技巧是線段樹二分搜。\n線段樹的每個節點可以存「節點包含的區間內最大的數」，所以對於每個詢問 $x$，我都可以去看是下面哪個 case\n左子樹的最大值 $\u0026gt;= x$ -\u0026gt; 往左子樹遞迴查詢 右子樹的最大值 $\u0026gt;= x$ -\u0026gt; 往右子樹遞迴查詢 都小於 -\u0026gt; 答案 $= 0$ 實作就看 code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; const int mxn = 2e5 + 5; int ans; struct Seg { ll seg[mxn \u0026lt;\u0026lt; 2], a[mxn]; void pullup(int id) { seg[id] = max(seg[id \u0026lt;\u0026lt; 1] , seg[id \u0026lt;\u0026lt; 1 | 1]); } void build(int l, int r, int id = 1) { if (l == r) { seg[id] = a[l]; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, id \u0026lt;\u0026lt; 1); build(mid + 1, r, id \u0026lt;\u0026lt; 1 | 1); pullup(id); } void bs(int l, int r, ll val, int id = 1) { // binary search on segment tree if (l == r) { if (seg[id] \u0026gt;= val) ans = l; seg[id] -= val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (seg[id \u0026lt;\u0026lt; 1] \u0026gt;= val) bs(l, mid, val, id \u0026lt;\u0026lt; 1); else if (seg[id \u0026lt;\u0026lt; 1 | 1] \u0026gt;= val) bs(mid + 1, r, val, id \u0026lt;\u0026lt; 1 | 1); pullup(id); } } seg; void solve() { int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; seg.a[i]; seg.build(1, n); while (q--) { ll x; cin \u0026gt;\u0026gt; x; ans = 0; seg.bs(1, n, x); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } int main() { ios::sync_with_stdio(0);cin.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) { solve(); } return 0; } ","permalink":"https://yun-20459.github.io/posts/cses-hotel-queries/","tags":["CSES","segment tree"],"title":"CSES Hotel Queries"},{"contents":"能幹嘛 區間最小/最大查詢，利用可以把區間拆成 $\\log_2(\\text{區間長度})$ 個長度為 2 的冪次的區間，達到 $O(N\\log(N))$ pre-build, $O(1)$ 查詢。\n（區間和查詢也可以，不過是 $O(\\log(N))$，而且可以用前綴和 $O(1)$）\n舉例來說，$[2, 10]$ 是一個長度為 9 的區間，那他就可以被拆成 $[2, 9] \\cup [10, 10]$，如果我可以提前知道這兩個區間的答案，那我就知道組合起來的答案。\n建 st 表的話可以看下面例題的 code， $st[i][j] :=$ 從 $i$ 開始長度為 $2^j$ 的區間的答案，那因為這樣的區間可以再拆成兩個長度為 $2^{j - 1}$ 的區間，所以可以用這兩個區間求答案。\nbtw 缺點是如果陣列值有改動的話就要重蓋 st 表，所以適用於不會改值的時候用。\n例題 CSES-Static Range Minimum Queries\n作法\n就是 sparse table 模板題，不過這題的話不用跟求 sum 一樣拆成好幾個不重疊的區間，因為求 min 的話就算拆成兩個重疊的也沒關係，所以就暴力拆成兩個 $\\log(r - l + 1)$ 長度的區間就可以查詢了。\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;ll, ll\u0026gt; pll; const int mxn = 2e5 + 5; const int logn = 19; int st[mxn][logn]; // sparse table, store answer for [i, i + 2^j - 1] int a[mxn]; // array int lg[mxn]; // log value int n, q; void init() { lg[1] = 0; for (int i = 2; i \u0026lt; mxn; i++) lg[i] = lg[i / 2] + 1; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; st[i][0]; for (int j = 1; j \u0026lt; logn; j++) { for (int i = 0; i + (1 \u0026lt;\u0026lt; j) \u0026lt;= n; i++) { st[i][j] = min(st[i][j - 1], st[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); } } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; init(); while (q--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; l--, r--; int j = lg[r - l + 1]; cout \u0026lt;\u0026lt; min(st[l][j], st[r - (1 \u0026lt;\u0026lt; j) + 1][j]) \u0026lt;\u0026lt; endl; } } int main() { ios::sync_with_stdio(0);cin.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) { solve(); } return 0; } 參考資料 cp algorithms\n","permalink":"https://yun-20459.github.io/posts/sparse-table/","tags":["CSES"],"title":"Sparse Table"},{"contents":"紀錄一下自己練習 dp 的過程，最近在寫 icpc 培訓班的作業感受到自己的 dp 實在是太爛了\u0026hellip; 剛好被推薦有這個題單可以練習，所以就順便把自己不會的東西整理一下變成一篇文，希望可以加深一點印象w\nbtw 如果是我本來就會的東西就不會寫解釋純貼 code。\n題單\nA. Frog 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const int maxn = 1e5 + 5; int h[maxn], dp[maxn]; void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; h[i]; dp[1] = 0, dp[2] = abs(h[2] - h[1]); for (int i = 3; i \u0026lt;= n; i++) { dp[i] = min(dp[i - 1] + abs(h[i] - h[i - 1]), dp[i - 2] + abs(h[i] - h[i - 2])); } cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; endl; } B. Frog 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const int maxn = 1e5 + 10; int h[maxn], dp[maxn]; void solve() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; h[i]; memset(dp, 0x3f, sizeof(dp)); dp[1] = 0; for (int i = 2; i \u0026lt;= n; i++) { for (int j = i - 1; j \u0026gt;= max(i - k, 1); j--) { dp[i] = min(dp[i], dp[j] + abs(h[i] - h[j])); } } cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; endl; } C. Vacation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const int maxn = 1e5 + 5; int val[3][maxn]; int dp[3][maxn]; void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) for (int j = 0; j \u0026lt; 3; j++) cin \u0026gt;\u0026gt; val[j][i]; for (int i = 0; i \u0026lt; 3; i++) { dp[i][1] = val[i][1]; } for (int i = 2; i \u0026lt;= n; i++) { dp[0][i] = max(dp[1][i - 1], dp[2][i - 1]) + val[0][i]; dp[1][i] = max(dp[0][i - 1], dp[2][i - 1]) + val[1][i]; dp[2][i] = max(dp[0][i - 1], dp[1][i - 1]) + val[2][i]; } cout \u0026lt;\u0026lt; max({dp[0][n], dp[1][n], dp[2][n]}) \u0026lt;\u0026lt; endl; } D. Knapsack 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const int maxn = 100 + 5; const int maxw = 1e5 + 5; ll w[maxn], v[maxn]; ll dp[maxn][maxw]; void solve() { int n, W; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; W; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; w[i] \u0026gt;\u0026gt; v[i]; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= W; j++) { if (j \u0026gt;= w[i]) dp[i][j] = max(dp[i - 1][j - w[i]] + v[i], dp[i - 1][j]); else dp[i][j] = dp[i - 1][j]; } } cout \u0026lt;\u0026lt; dp[n][W] \u0026lt;\u0026lt; endl; } E. Knapsack 2 因為這次的重量上限到 1e9，所以不能直接套 D 的做法，但這次的價值上限是 1e3，所以可以利用這點，把狀態定成 $dp_{i, j} := $ 考慮第 $i$ 個物品的時候，價錢拿到 $j$ 的重量最小值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const int maxv = 1000 + 5; const int maxn = 100 + 5; int dp[maxn][maxn * maxv]; int w[maxn], v[maxn]; void solve() { int N, W; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; W; for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; w[i] \u0026gt;\u0026gt; v[i]; memset(dp, 0x3f, sizeof(dp)); dp[0][0] = 0; for (int i = 1; i \u0026lt;= N; i++) { for (int j = 0; j \u0026lt;= N * 1000; j++) { if (j \u0026lt; v[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]); } } int ans; for (int j = 0; j \u0026lt;= N * 1000; j++) { if (dp[N][j] \u0026lt;= W) ans = j; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } F. LCS 這題的重點是要會輸出一組解，那找的方式其實就是看當初怎麼算出來的，就反著回去做。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const int maxn = 3000 + 5; int dp[maxn][maxn]; void solve() { string s, t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; int n1 = s.length(), n2 = t.length(); for (int i = 1; i \u0026lt;= n1; i++) { for (int j = 1; j \u0026lt;= n2; j++) { if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } // trace(dp[n1][n2]); string ans = \u0026#34;\u0026#34;; int i = n1, j = n2; while (dp[i][j] \u0026gt; 0) { if (s[i - 1] == t[j - 1]) { ans = s[i - 1] + ans; i--, j--; } else { if (dp[i][j] == dp[i - 1][j]) i--; else j--; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } G. Longest Path 有向無環圖找最長路，這題應該有蠻多作法的，不過我第一個就想到 dfs 所以就寫 dfs。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const int maxn = 1e5 + 5; vector\u0026lt;int\u0026gt; g[maxn]; bool vis[maxn]; int dp[maxn], ans; void dfs(int u) { vis[u] = 1; for (int v : g[u]) { if (!vis[v]) dfs(v); dp[u] = max(dp[u], dp[v] + 1); } ans = max(ans, dp[u]); } void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0, u, v; i \u0026lt; m; i++) { cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; g[u].eb(v); } for (int i = 1; i \u0026lt;= n; i++) { if (!vis[i]) dfs(i); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } H. Grid 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 const int maxn = 1000 + 5; char g[maxn][maxn]; int dp[maxn][maxn]; void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { cin \u0026gt;\u0026gt; g[i][j]; } } dp[0][0] = 1; for (int i = 1; i \u0026lt; n; i++) { if (g[i][0] == \u0026#39;.\u0026#39;) dp[i][0] = 1; else break; } for (int i = 1; i \u0026lt; m; i++) { if (g[0][i] == \u0026#39;.\u0026#39;) dp[0][i] = 1; else break; } for (int i = 1; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt; m; j++) { if (g[i][j] == \u0026#39;.\u0026#39;) dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % mod; } } cout \u0026lt;\u0026lt; dp[n - 1][m - 1] \u0026lt;\u0026lt; endl; } I. coins 想一下就會發現跟背包很類似，都是可以決定當前這個取不取，然後從上一個狀態轉移過來。\n具體來說，定義 $dp_{i, j} :=$ 前 $i$ 個錢幣中有 $j$ 個硬幣向上，所以就可以分成兩個 cases\n當前的向上 $\\rightarrow dp_{i, j} = p[i] * dp_{i - 1, j - 1}$ 當前的向下 $\\rightarrow dp_{i, j} = (1 - p[i]) * dp_{i - 1, j}$ 最後他要求正多於反，就加一下就好。 btw 邊界條件要設好，我漏設了 debug 好久 QQ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 const int maxn = 3000 + 5; double p[maxn], dp[maxn][maxn]; void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; p[i]; dp[0][0] = 1.0; for (int i = 1; i \u0026lt;= n; i++) { dp[i][0] = dp[i - 1][0] * (1 - p[i]); for (int j = 1; j \u0026lt;= i; j++) { dp[i][j] = p[i] * dp[i - 1][j - 1] + (1 - p[i]) * dp[i - 1][j]; } } double ans = 0.0; for (int head = (n + 1) / 2; head \u0026lt;= n; head++) { ans += dp[n][head]; } cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(12) \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } J. Sushi 第一次寫到跟期望值有關的 dp，定狀態的方法其實跟其他的也差不多。\n這題的定義是 $dp_{i, j, k} :=$ 壽司數量 1, 2, 3 的分別有 $i$, $j$, $k$ 個，把這些都吃到剩 0 的期望值，轉移的話可以看 code\n要注意的兩個小重點\n要先 run $k$，我看了一些題解不太懂「無後效性」是什麼意思，我的理解是因為一些變成 1 2 的是從 3 來的，所以要先跑 假設當前選的是吃有 2 個盤子，那他會是從 $dp_{i + 1, j - 1, k}$ 轉移過來，代表是多吃一個 2 個的，但因為一次只能吃一個，所以多吃的這個一定是從 1 個的那邊來的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const int maxn = 300 + 5; double dp[maxn][maxn][maxn]; int a[4]; void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { int x; cin \u0026gt;\u0026gt; x; a[x]++; } for (int k = 0; k \u0026lt;= n; k++) { for (int j = 0; j \u0026lt;= n; j++) { for (int i = 0; i \u0026lt;= n; i++) { if (!i and !j and !k) continue; if (i) dp[i][j][k] += i * dp[i - 1][j][k]; if (j) dp[i][j][k] += j * dp[i + 1][j - 1][k]; if (k) dp[i][j][k] += k * dp[i][j + 1][k - 1]; dp[i][j][k] = (dp[i][j][k] + n) / (i + j + k); } } } cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(12) \u0026lt;\u0026lt; dp[a[1]][a[2]][a[3]] \u0026lt;\u0026lt; endl; } ","permalink":"https://yun-20459.github.io/posts/atcoder-dp-contest/","tags":["Atcoder","dp"],"title":"Atcoder DP contest (持續更新中)"},{"contents":"大學生混進高中競程營隊裝年輕（Ｘ\n一開始來的時候目標是想要練刷題，結果剛好被朋友推坑去 icpc 培訓班 hw0.514，所以就希望這次營隊能多學一點，看對 hw0.514 有沒有幫助（對 icpc 有沒有幫助不好說，都還不知道自己能不能寫到錄取門檻 QQ）\n打一點上課比賽心得，順便紀錄不會的東西方便以後回來補坑\nDay 1 基本技巧 + 基礎資料結構\n基本技巧不知道的有離散化、lambda、三分搜，基礎資結大部分東西 dsa 都上過，不知道（or 不太熟）的有線段樹、BIT、Sparse Table\n今天沒有比賽\nDay 2 進階資料結構、基礎 dp\n進階資料結構線段樹好難 QQ，套其他資結更難，我什麼都不會 QQ。 基礎 dp 例題都會之後就看經典問題能不能自己推出轉移ㄅ\n今天的團賽是團體賽，隊伍拿 407 我拿 400，好開心w\n不過我還是只會解水題 Q，甚至有一題官解兩個做法我都有想到，但就是寫不出來，哭了\nDay 3 進階 dp、基礎圖論（、計算幾何）\n進階 dp 一開始的優化還好，線段樹優化、單調隊列優化、斜率優化還要再多練練了，連講師上課講解有些小部分都不是很懂 QQ，基礎圖論 ada 幾乎都上過，不過 拓樸排序 跟 判二分圖沒自己寫過。\n計算幾何不在日程表上，但因為斜率優化跟凸包有關所以講師們多補了電子檔給我們讚讚 \u0026gt;\u0026lt; 要找時間補起來ㄌ\n比賽燒雞燒好燒滿，拿了兩題後就不會做事了 Q 少拿 A 96 分的區間 dp，E 的最短路徑樹，都有點想法但沒時間做出來可惜\nDay 4 進階圖論 slide、數論\n圖論也是大部分 ada 教過，不過我樹序列化跟樹鏈剖分死掉了，要找時間補（HLD 看起來是實作地獄）\n今天比賽沒那麼燒，可是 G 是類 ada 作業然後我完全忘記對答案二分搜的概念 = = 氣死\nDay5 其他解題技巧（、昨天沒上完的數論）\n各種我不會的東西 QQ，要補分塊跟莫隊，今天是團賽，邊聽題解邊發現我好多題算法都是對的但實作都出包拿不到分數 = = 真的是實作燒雞欸\nbtw 今天被通知錄取 ada mini hw 組了，好快樂\n","permalink":"https://yun-20459.github.io/posts/2022-ionc/","tags":["IONC"],"title":"2022 IONC"},{"contents":"題目 link\n作法 純純的三分搜，只是我一開始沒看懂題目就開始亂寫，然後又在「求出 $L(x)$ 這部分卡住」，後來學長開導（？）我之後才知道其實就是在三分搜的時候原本是問一個函數，現在他要的是所有函數集合的最小值，那就 $O(n)$ 問過去就好了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long int ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;pii\u0026gt; vii; const int inf = 0x3f3f3f3f; const int ninf = 0xc0c0c0c0; const double dinf = numeric_limits\u0026lt;double\u0026gt;::max(); const double dninf = numeric_limits\u0026lt;double\u0026gt;::min(); const double eps = 1e-9; #define AC ios_base::sync_with_stdio(0), cin.tie(0); #define rep(i, j, k) for (int i = j; i \u0026lt; k; i++) #define repb(i, j, k) for (int i = j; i \u0026gt;= k; i--) #define all(v) (v).begin(), (v).end() #define endl \u0026#39;\\n\u0026#39; #define F first #define S second #define err(a) cerr \u0026lt;\u0026lt; #a \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl typedef struct Func { double a, b, c; } Func; double f(Func func, double x) { return func.a * x * x + func.b * x + func.c; } double triSearch(vector\u0026lt;Func\u0026gt;\u0026amp; vf, double lowest_x, double highest_x) { double low = lowest_x, l, r, high = highest_x; int n = vf.size(); while (high - low \u0026gt; eps) { l = low + (high - low) / 3, r = l + (high - low) / 3; double lv = dinf, rv = dinf; rep(i, 0, n) { lv = min(lv, f(vf[i], l)); rv = min(rv, f(vf[i], r)); } if (lv \u0026lt; rv) low = l; else high = r; } return low; } int main() { AC; int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;Func\u0026gt; v(n); rep(i, 0, n) { cin \u0026gt;\u0026gt; v[i].a \u0026gt;\u0026gt; v[i].b \u0026gt;\u0026gt; v[i].c; } cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(6) \u0026lt;\u0026lt; triSearch(v, 0.0, 60.0 * 24.0 * 94.0) \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://yun-20459.github.io/posts/tioj-1882-pc-%E6%9C%80%E6%9A%96%E7%9A%84%E5%86%AC%E5%A4%A9/","tags":["TIOJ","tenary search"],"title":"TIOJ 1882. pC. 最暖的冬天"},{"contents":"題目 有一個陣列 ${1, 2, \u0026hellip;, N}, (N \\leq 10^6)$，Petr 喜歡對序列執行 $3n$ 次任取兩個數字交換的操作，Um_nik 喜歡做 $7n + 1$ 次，給定一個操作後的陣列，求是誰操作的。\n作法 把 index 跟陣列數值想成是圖中有連接的點的話，一開始未操作的陣列會有 $n$ 個自環，每一次操作會增加或減少一個環，由 $3n$ 跟 $7n + 1$ 的奇偶性不同可以判斷是誰操作的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long int ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;bool\u0026gt; vb; typedef vector\u0026lt;pii\u0026gt; vii; typedef vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; vvi; #define AC ios_base::sync_with_stdio(0), cin.tie(0); #define rep(i, j, k) for (int i = j; i \u0026lt; k; i++) #define all(v) (v).begin(), (v).end() #define pb(x) push_back(x) #define endl \u0026#39;\\n\u0026#39; #define F first #define S second #define inf 0x3f3f3f3f #define ninf 0xc0c0c0c0 #define eps 1e-9 #define err(a) cerr \u0026lt;\u0026lt; #a \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl void dfs(vvi\u0026amp; adj, vb\u0026amp; vis, int i) { vis[i] = 1; for (auto u : adj[i]) { if (!vis[u]) dfs(adj, vis, u); } } int main() { AC; int n; cin \u0026gt;\u0026gt; n; vvi adj(n + 1, vector\u0026lt;int\u0026gt;()); rep(i, 1, n + 1) { int x; cin \u0026gt;\u0026gt; x; adj[i].pb(x); } int cycle = 0; vb vis(n + 1); rep(i, 1, n + 1) { if (!vis[i]) { cycle++; dfs(adj, vis, i); } } if (!(cycle % 2)) puts(\u0026#34;Petr\u0026#34;;) else puts(\u0026#34;Um_nik\u0026#34;); return 0; } 另一個實作方法，寫起來比較快，不用開 vis 陣列，概念是一樣的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long int ll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;bool\u0026gt; vb; typedef vector\u0026lt;pii\u0026gt; vii; typedef vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; vvi; #define AC ios_base::sync_with_stdio(0), cin.tie(0); #define rep(i, j, k) for (int i = j; i \u0026lt; k; i++) #define all(v) (v).begin(), (v).end() #define pb(x) push_back(x) #define endl \u0026#39;\\n\u0026#39; #define F first #define S second #define inf 0x3f3f3f3f #define ninf 0xc0c0c0c0 #define eps 1e-9 #define err(a) cerr \u0026lt;\u0026lt; #a \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl int main() { AC; int n; cin \u0026gt;\u0026gt; n; vi v(n); rep(i, 1, n + 1) { cin \u0026gt;\u0026gt; v[i]; } int res = 0; rep(i, 1, n + 1) { if (!v[i]) continue; res ^= 1; int x = i; while (x) { int y = v[x]; v[x] = 0; x = y; } } if (res \u0026amp; 1) puts(\u0026#34;Um_nik\u0026#34;); else puts(\u0026#34;Petr\u0026#34;); return 0; } ","permalink":"https://yun-20459.github.io/posts/codeforces-986b-petr-and-permutations/","tags":["Codeforces","math","graph","dfs"],"title":"Codeforces 986B. Petr and Permutations"},{"contents":"試著記得每次都要寫複雜度（？\n題目 link\n作法 一開始看到 tag 以為真的要寫 trie，後來才發現不用（用 trie 我也不會寫），用二分搜就可以了。\n概念是先去紀錄 s 每個字母有出現在哪裡，然後去遍歷每個 word，對於 word 裡的每一個字母，我都要能在 s 裡面找到比前一個字母在 s 裡面的位置更後面的位置（好拗口），這樣才符合 subsequence of string。\n舉例來說\n1 2 s = \u0026#34;abcd\u0026#34; words = [\u0026#34;ab\u0026#34;, \u0026#34;cb\u0026#34;] 顯然對於 \u0026quot;ab\u0026quot; 來說，我可以在 s 裡面找到 1 跟 2 這兩個位置，所以他是對的，但對於 \u0026quot;cb\u0026quot; 來說，c 的第一個位置就是 3 了，而 3 後面沒有 b 所以他是錯的。\n假設 s 長度是 $L$，$words$ 陣列長度是 $N$，每個 word 長度是 $l$，複雜度會是 $O(LNlog(l))$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: int numMatchingSubseq(string s, vector\u0026lt;string\u0026gt;\u0026amp; words) { vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; ch(26); int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { ch[s[i] - \u0026#39;a\u0026#39;].push_back(i); } int ans = 0; for (auto \u0026amp;word: words) { int id = -1; bool found = true; for (char c : word) { auto idx = upper_bound(ch[c - \u0026#39;a\u0026#39;].begin(), ch[c - \u0026#39;a\u0026#39;].end(), id); if (idx == ch[c - \u0026#39;a\u0026#39;].end()) { found = false; break; } id = *idx; } if (found) ans++; } return ans; } }; ","permalink":"https://yun-20459.github.io/posts/leetcode-792-number-of-matching-subsequences/","tags":["Leetcode","binary search","string"],"title":"Leetcode 792. Number of Matching Subsequences"},{"contents":"題目 link\n作法 $O(nk^2)$ 我以為會 TLE 然後剛剛測發現其實不會 QQ，可以定義 $dp[i][j]$ 是使用 1 ~ $i$ 的數字後，可以構成 $j$ 個 inversion pair 的數量，那答案就會是 $dp[n][k]$。\n轉移式的話可以觀察，如果我現在已經放好 1~3 然後我要把 4 放進去這個序列裡面，我可以有下面這幾種放法\n放法 造成的逆序數對 4xxx 3 x4xx 2 xx4x 1 xxx4 0 所以就可以發現這樣的轉移式\n$dp[i][j] = dp[i - 1][j - k]$, $\\forall k \\in [0, i - 1]$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int kInversePairs(int n, int k) { const int mod = 1e9 + 7; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; dp(n + 1, vector\u0026lt;int\u0026gt;(k + 1, 1)); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= k; j++) { for (int k = 0; k \u0026lt;= min(K, N - 1); k++) { dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % mod; } } } return dp[n][k]; } }; $O(nk)$ 同樣的概念，只是剛剛的轉移式可以再優化\n$j \u0026lt; i$\n$$\n\\begin{aligned}\ndp[i][0] \u0026amp;= dp[i - 1][0] \\\\\ndp[i][1] \u0026amp;= dp[i - 1][0] + dp[i - 1][1] = dp[i][0] + dp[i - 1][1] \\\\\ndp[i][2] \u0026amp;= dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2] = dp[i][1] + dp[i - 1][2] \\\\\n\u0026amp;\\vdots \\\\\ndp[i][j] \u0026amp;= dp[i][j - 1] + dp[i - 1][j]\n\\end{aligned}\n$$\n$j \u0026gt;= i$\n$$\n\\begin{aligned}\ndp[i][j] \u0026amp;= dp[i - 1][j] + dp[i - 1][j - 1] + \\cdots + dp[i - 1][j - i + 1] + (dp[i - 1][j - i] - dp[i - 1][j - i]) \\\\\n\u0026amp;= dp[i - 1][j] + (dp[i - 1][j - 1] + \\cdots + dp[i - 1][j - i + 1] + dp[i - 1][j - i]) - dp[i - 1][j - i] \\\\\n\u0026amp;= dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - i]\n\\end{aligned}\n$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int kInversePairs(int n, int k) { const int mod = 1e9 + 7; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; dp(n + 1, vector\u0026lt;int\u0026gt;(k + 1)); dp[0][0] = 1; for (int i = 1 ; i \u0026lt;= n; i++) { dp[i][0] = 1; for (int j = 1; j \u0026lt;= k; j++) { dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod; if (j \u0026gt;= i) dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod; } } return dp[n][k]; } }; 題外話 mathjax 在 version 3 沒有支援 \\\\ 換行，會被 render 掉，所以要寫 \\\\\\\\\n","permalink":"https://yun-20459.github.io/posts/leetcode-629-k-inverse-pairs-array/","tags":["Leetcode","dp","sliding window"],"title":"Leetcode 629. K Inverse Pairs Array"},{"contents":"題目 link\n作法 bit manipulation + dp 這題跟 這題 蠻像的，不過這次是要盡可能平均分然後輸出這樣分以後一個小孩最多可能拿到的餅乾數。\n我一開始想跟 698 那題一樣做，不過這樣的話是沒辦法知道 max 的，因為只能用袋子分而不是直接拿餅乾分，所以要換一個方法。\n定義 dp[i][mask] 為當人數有 $i$ 個的時候取的 subset 為 $mask$ 時，拿到最多餅乾的小孩的餅乾數量的最小值，就會有以下的轉移式\ndp[i][mask] = min(dp[i][mask], max(dp[i - 1][mask ^ submask], sum[submask]))\n意思是說在這群小孩裡面有個小孩拿了 submask 這樣的 subset，剩下的小孩拿其他的，看最大值會是多少，然後因為我最後要的是最小化最大值，所以取 min。\n關於 enumerating submask of mask 可以看 這篇 講解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: int distributeCookies(vector\u0026lt;int\u0026gt;\u0026amp; cookies, int k) { int n = cookies.size(); vector\u0026lt;int\u0026gt; sum(1 \u0026lt;\u0026lt; n, 0); for (int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; n); mask++) { for (int i = 0; i \u0026lt; n; i++) { if ((mask \u0026gt;\u0026gt; i) \u0026amp; 1) { sum[mask] += cookies[i]; } } } vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; dp(k + 1, vector\u0026lt;int\u0026gt;(1 \u0026lt;\u0026lt; n, INT_MAX)); dp[0][0] = 0; for (int person = 1; person \u0026lt;= k; person++) { for (int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; n); mask++) { for (int submask = mask; submask; submask = (submask - 1)\u0026amp;mask) { dp[person][mask] = min(dp[person][mask], max(sum[submask], dp[person - 1][mask ^ submask])); } } } return dp[k][(1 \u0026lt;\u0026lt; n) - 1]; } }; 剪枝 dfs code by 蕭啟湘\n概念是不管給那個小孩都是一樣的，在分第 $n$ 個餅乾的時候，只分成「拿過餅乾的小孩總數 + 1」種 case，因為拿過餅乾的小孩就不一樣了，剩下「+1」的 case 是指分給還沒有拿過餅乾的小孩的情況，下面為了可以更好地理解這段話故意把 for loop 最後一個 case 拆出來寫，其實是可以合併的啦\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: int ans = INT_MAX; int dfs(vector\u0026lt;int\u0026gt;\u0026amp; child, vector\u0026lt;int\u0026gt;\u0026amp; cookies, int cookieBagId, int numberOfPeopleHavingCookies, int childNum, int size){ if(cookieBagId == size) { return *max_element(child.begin() , child.end()); } int cases = min(numberOfPeopleHavingCookies + 1, childNum); for (int i = 0 ; i \u0026lt; cases - 1; i++) { child[i] += cookies[cookieBagId]; ans = min(ans, dfs(child, cookies, cookieBagId + 1 , numberOfPeopleHavingCookies, childNum, size)); child[i] -= cookies[cookieBagId]; } child[cases - 1] += cookies[cookieBagId]; ans = min(ans, dfs(child, cookies, cookieBagId + 1 , numberOfPeopleHavingCookies + 1, childNum, size)); child[cases - 1] -= cookies[cookieBagId]; return ans; } int distributeCookies(vector\u0026lt;int\u0026gt;\u0026amp; cookies, int k) { vector\u0026lt;int\u0026gt; child(k, 0); return dfs(child, cookies, 0, 0, k, cookies.size()); } }; ","permalink":"https://yun-20459.github.io/posts/leetcode-2305-fair-distribution-of-cookies/","tags":["Leetcode","dp","bit manipulation"],"title":"Leetcode 2305. Fair Distribution of Cookies"},{"contents":"好像比較了解 bit manipulation 可以幹嘛了（？）\n題目 link\n做法 這題是 這題 的進化版（？），要分成 $k$ 堆，一樣可以用 bit + dp 做，然後這邊還有一個小技巧是直接用餘數，這樣就可以直接在最後判是不是等於 0，如果不用餘數的話可能就要寫個 if 或者用更複雜的方式去判現在這個 element 能不能被放進這個 subset\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: bool canPartitionKSubsets(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int sum = 0; for (int num : nums) sum += num; if (sum % k) return false; int target = sum / k; int n = nums.size(); vector\u0026lt;int\u0026gt; dp(1 \u0026lt;\u0026lt; n, -1); dp[0] = 0; sort(nums.begin(), nums.end()); for (int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; n); mask++) { if (dp[mask] == -1) continue; for (int j = 0; j \u0026lt; n; j++) { if (!(mask \u0026amp; (1 \u0026lt;\u0026lt; j)) and dp[mask] + nums[j] \u0026lt;= target) { dp[mask | (1 \u0026lt;\u0026lt; j)] = (dp[mask] + nums[j]) % target; } } } return dp[(1 \u0026lt;\u0026lt; n) - 1] == 0; } }; ","permalink":"https://yun-20459.github.io/posts/leetcode-698-partition-to-k-equal-sum-subsets/","tags":["Leetcode","dp","bit manipulation"],"title":"Leetcode 698. Partition to K Equal Sum Subsets"},{"contents":"不會 dp 也不會 bit manipulation QAQ\n題目 link\n作法 dfs 一個最簡單的做法可以直接 recursion, code 如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: bool chk(vector\u0026lt;int\u0026gt;\u0026amp; side, vector\u0026lt;int\u0026gt;\u0026amp; matches, int id, int n) { if (id == n) { return side[0] == side[1] and side[1] == side[2] and side[2] == side[3]; } for (int i = 0; i \u0026lt; 4; i++) { side[i] += matches[id]; if (chk(side, matches, id + 1, n)) return true; side[i] -= matches[id]; } return false; } bool makesquare(vector\u0026lt;int\u0026gt;\u0026amp; matches) { int n = match.size(); vector\u0026lt;int\u0026gt; sideLen(4, 0); return chk(sideLen, matches, id, n); } }; 但是這樣會 TLE，所以需要做一點優化\n如果總火柴長度 mod 4 $\\neq$ 0 的話，就不可能拚成正方形 根據 1.，如果已經有邊的長度 \u0026gt; 總火柴長度 / 4，就不用繼續遞迴 如果前面有一樣的 sideLen 檢查過不可行，就不用繼續遞迴 把火柴長度從大排到小，這樣就可以比較快 return false 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public: #define ll long long int bool chk(vector\u0026lt;ll\u0026gt;\u0026amp; side, vector\u0026lt;int\u0026gt;\u0026amp; matches, int id, int n, const ll target) { if (id == n) { return side[0] == side[1] and side[1] == side[2] and side[2] == side[3]; } for (int i = 0; i \u0026lt; 4; i++) { if (side[i] + (ll)matches[id] \u0026gt; target) continue; int j = i; while (--j \u0026gt;= 0) { if (side[i] == side[j]) break; } if (j != -1) continue; side[i] += (ll)matches[id]; if (chk(side, matches, id + 1, n, target)) return true; side[i] -= (ll)matches[id]; } return false; } bool makesquare(vector\u0026lt;int\u0026gt;\u0026amp; matches) { int n = matches.size(); vector\u0026lt;ll\u0026gt; sideLen(4, 0); ll sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += (ll)matches[i]; } if (sum % 4) return false; ll target = sum / 4; sort(matches.begin(), matches.end(), greater\u0026lt;int\u0026gt;()); return chk(sideLen, matches, 0, n, target); } }; bit manipulation + dp 上面都不是重點\n下面才是我真的想要分享的 part，在 discussion 看到這個做法覺得太漂亮了 \u0026gt;\u0026lt;\n首先還是先需要知道每個邊的長度，接下來就用 bit 來表示取了哪幾個火柴，如果有一個 subset 可以拼成一條正方形的邊的話，那麼我就把這個 subset 存起來，然後利用 and 去看前面存起來的有沒有跟我是沒有交集的 subset，如果有的話代表我可以形成兩條邊，剩下就是利用 xor 去檢查全部的 set 扣掉這兩條邊是不是可以形成剩下的兩條邊\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public: #define ll long long int bool makesquare(vector\u0026lt;int\u0026gt;\u0026amp; v) { ll sum = 0; int n = v.size(); for (int i = 0; i \u0026lt; n; i++) { sum += (ll)v[i]; } if (sum % 4) return false; ll sideLen = sum / 4; int allset = (1 \u0026lt;\u0026lt; n) - 1; vector\u0026lt;bool\u0026gt; validHalf(1 \u0026lt;\u0026lt; n, false); vector\u0026lt;int\u0026gt; availableMask; for (int mask = 0; mask \u0026lt;= allset; mask++) { ll subsetNum = 0; for (int i = 0; i \u0026lt; 32; i++) { subsetNum += ((mask \u0026gt;\u0026gt; i) \u0026amp; 1) ? (ll)v[i] : 0LL; } if (subsetNum == sideLen) { for (int am : availableMask) { if ((am \u0026amp; mask) == 0) { int validhalf = am | mask; validHalf[validhalf] = true; if (validHalf[allset ^ validhalf]) return true; } } availableMask.push_back(mask); } } return false; } }; ","permalink":"https://yun-20459.github.io/posts/leetcode-473-matchsticks-to-square/","tags":["Leetcode","dp","bit manipulation","dfs"],"title":"Leetcode 473. Matchsticks to Square"},{"contents":"creating object 定義物件的時候用 object literal syntax 較好，這個的意思是把 property 跟 value 用類似 array 的方式來寫，例如說\n1 2 3 4 5 6 7 const myObject = { property: \u0026#39;Value!\u0026#39;, otherProperty: 77, \u0026#34;obnoxious property\u0026#34;: function() { // do stuff! } } 可以用 dot notation 或者 bracket notation 拿資料\n1 2 3 4 5 // dot notation myObject.property // \u0026#39;Value!\u0026#39; // bracket notation myObject[\u0026#34;obnoxious property\u0026#34;] // [Function] function 定義在 prototype 比較好，不然每 new 一個 object 出來就會複製一次\n1 2 3 4 5 6 7 8 9 10 11 function Student(name, grade) { this.name = name this.grade = grade } Student.prototype.sayName = function() { console.log(this.name) } Student.prototype.goToProm = function() { console.log(\u0026#34;Eh.. go to prom?\u0026#34;) } prototypal inheritance 建議用 Object.create\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function Student() { } Student.prototype.sayName = function() { console.log(this.name) } function EighthGrader(name) { this.name = name this.grade = 8 } EighthGrader.prototype = Object.create(Student.prototype) const carl = new EighthGrader(\u0026#34;carl\u0026#34;) carl.sayName() // console.logs \u0026#34;carl\u0026#34; carl.grade // 8 Factory function\n因為用 constructor 可能會有很多可能會有很多非預期錯誤，所以可以使用 factory function 來 create object\n1 2 3 4 5 6 7 8 9 10 const personFactory = (name, age) =\u0026gt; { const sayHello = () =\u0026gt; console.log(\u0026#39;hello!\u0026#39;); return { name, age, sayHello }; }; const jeff = personFactory(\u0026#39;jeff\u0026#39;, 27); console.log(jeff.name); // \u0026#39;jeff\u0026#39; jeff.sayHello(); // calls the function and logs \u0026#39;hello!\u0026#39; inheritance:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const Person = (name) =\u0026gt; { const sayName = () =\u0026gt; console.log(`my name is ${name}`); return {sayName}; } const Nerd = (name) =\u0026gt; { // simply create a person and pull out the sayName function with destructuring assignment syntax! const {sayName} = Person(name); const doSomethingNerdy = () =\u0026gt; console.log(\u0026#39;nerd stuff\u0026#39;); return {sayName, doSomethingNerdy}; } const jeff = Nerd(\u0026#39;jeff\u0026#39;); jeff.sayName(); //my name is jeff jeff.doSomethingNerdy(); // nerd stuff class\n有 getter 跟 setter 可以用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class User { constructor(name) { // invokes the setter this.name = name; } get name() { return this._name; } set name(value) { if (value.length \u0026lt; 4) { alert(\u0026#34;Name is too short.\u0026#34;); return; } this._name = value; } } webpack 打包檔案的模組化好工具，可以看這個人的 介紹\nSOLID principle Single Responsibility Principle Open-Closed Principle: open to extension but close to modification，舉例來說當我想要擴建某個 function 的時候我應該要可以直接在 import code 那邊可以擴建而不是去更改 import 的 code Liskov Substitution Principle Interface Segregation: export code 的時候 require 必要的東西，剩下的 optional Dependency Inversion Principle: 大概是上層的模組不依賴下層的，而是用 interface 去實現兩個的接口（？） 介紹 linting vscode eslint 教學\nconstraint validation 使用 html + js 做 validation\n","permalink":"https://yun-20459.github.io/posts/frontend-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-organizing-js/","tags":["js"],"title":"frontend 學習筆記 - organizing js"},{"contents":"grid 是什麼 一種 display 的方法，可以 display grid （廢話）\n常用 property \u0026amp; function grid-template-columns、grid-template-rows: 設定有幾行/列，並給訂每一行/列的寬度 給的時候可以用 repeat(次數, 寬度) 來給，其中寬度的單位可以是 px 或 fr (fraction unit) grid-auto-rows、grid-auto-columns: 設定 template 以外的行/列 grid-auto-flow: 指定多出來的 grid 要往哪裡長 gap: 可以同時設定 row-gap、column-gap resize: both: 可以讓 user 調整 grid container 的大小 overflow: auto: 如果 container 變太小就可以自動調整成滾動式內容 minmax(): 只能用在 grid-template-columns、grid-template-rows、grid-auto-rows、grid-auto-columns，給 container shrink and grow 最小和最大值 auto-fit、auto-fill: 會自動依據 container 的大小調整個數，兩個的差別在如果 grid 大到可以容納其他 item 但沒有其他 item 的時候， auto-fit 會用 max， auto-fill 會用 min auto-fit 例子 auto-fill 例子 positioning grid-column-start、grid-column-end、grid-row-start、grid-row-end: 可以固定透過 line 固定 grid cell 的位置 可以直接用 grid-area 來表示 grid-row-start / grid-column-start / grid-row-end / grid-column-end grid-area 也可以直接給 value，然後再用 grid-template-area 排，空的地方就用 . 代表 例子 span: 這個 keyword 可以直接指定 number of track to span 詳細解說 other css tricks 相關練習 ","permalink":"https://yun-20459.github.io/posts/frontend-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-grid/","tags":["csss"],"title":"frontend 學習筆記 - grid"},{"contents":"題目 link\n作法 令 dp[i] 為以 $i$ 為起點到終點能獲得的最大分數。如果枚舉可以走的範圍內最大的話複雜度會是 $O(nk)$ 會 TLE，所以可以用 deque 或是 priority_queue 來優化，維護一個可以走的範圍內的單調隊列或者 heap，就可以在 $O(1)$ 或是 $O(logk)$ 內拿到最大值了。\n下面兩種 code 分別用 deque 和 priority_queue 寫， deque 版本是從起點開始做，priority_queue 版本是從終點開始做\ndeque 版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int maxResult(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); vector\u0026lt;int\u0026gt; dp(n, 0); deque\u0026lt;int\u0026gt; dq; dp[0] = nums[0]; dq.push_back(0); for (int i = 1; i \u0026lt; n; i++) { if (dq.front() \u0026lt; i - k) dq.pop_front(); dp[i] += nums[i] + dp[dq.front()]; while (!dq.empty() \u0026amp;\u0026amp; dp[i] \u0026gt;= dp[dq.back()]) dq.pop_back(); dq.push_back(i); } return dp[n - 1]; } }; priority_queue 版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int maxResult(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; pq; vector\u0026lt;int\u0026gt; dp(n, 0); for (int i = n - 1; i \u0026gt;= 0; i--) { while (!pq.empty() and pq.top().second \u0026gt; i + k) pq.pop(); dp[i] = nums[i]; dp[i] += (pq.empty() ? 0 : pq.top().first); pq.push({dp[i], i}); } return dp[0]; } }; ","permalink":"https://yun-20459.github.io/posts/leetcode-1696-jump-game-vi/","tags":["Leetcode","dp","priority_queue","deque"],"title":"Leetcode 1696. Jump Game VI"},{"contents":"建立 form 範例 code\n\u0026lt;form\u0026gt; action: 後面要放的是 url，代筆要送資料去處理的地方 method: 送這個 form 的 http request method \u0026lt;input\u0026gt; type: 輸入的形式，可以是 radio: 圓圓的選擇按鍵 checked: 預設選起來的選項 checkbox: 可以打勾的清單符號 checked: 預設選起來的選項 text: 文字 number: 數字 email: 就是 email password: 會自動把使用者輸入用 * 遮掉 date: 日期 url: 網址 placeholder: 在輸入框內提示你的輸入應該會長怎樣 name: 資料放在 form control 後的 reference required: 必須填寫 title: 可以提供 validation msg \u0026lt;label\u0026gt; for: 這個屬性要跟搭配的 \u0026lt;input\u0026gt; 的 id 一樣 \u0026lt;textarea\u0026gt;: 給使用者寫文字的地方，可以調整長寬也可以預先輸入文字 \u0026lt;select\u0026gt;: 選單 \u0026lt;option\u0026gt;: 就是選單裡面的選項 value: 會傳到 server 的值 selected: 預設選起來的選項 \u0026lt;optgroup\u0026gt;: 選單裡面的大類別 label: 顯示給使用者看的大類別 \u0026lt;button\u0026gt; type submit: 預設值，會送出 form reset: 重設 form button: 最 general 的一種 \u0026lt;fieldset\u0026gt;: 可以把相關的 form 弄在一起 \u0026lt;legend\u0026gt;: fieldset 中顯示給使用者看這個 fieldset 的主題 form 驗證 text validation minlength maxlength pattern: 吃 regex 來判斷 (regex 另一份教學) number validation min max styling 可以用 :valid 跟 :invalid 這兩個 pseudo class 來做\nform validation UX\nreport error how to report errors\n","permalink":"https://yun-20459.github.io/posts/frontend-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-form/","tags":["html"],"title":"frontend 學習筆記 - form"},{"contents":"我真的不會 dp QwQ\n題目 link\n作法 可以先從基礎題開始想，就是判合法括號字串，這個用 stack 就可以解決（其實這題也可，但我想練 dp），從這個的想法出發的話，可以先想到\n如果前一個是 ( 後一個是 )，那就有一個長度為 2 的合法括號字串 如果以 dp[i] 來記錄以 $i 為結尾最長合法括號字串長度的話， 1. 可以寫成 dp[i] = dp[i - 1] + 2，要注意這個是建立在你已經知道前面有 ( 了。\n接下來再考慮這個 case ()()，因為 dp[i] 要記錄的是以 $i$ 為結尾最長合法括號字串長度，所以前面合法括號字串長度也要算進來，這個的算法可以利用現在紀錄的長度跟 index 來算。\n以這個 case 來說，它其實可以切成兩個 ()，在算第二個的時候按照上面的式子只會記錄到長度 2，，所以要去看 i - dp[i] 這個 index dp 值存的是多少然後加起來。\n就有\nif (i - dp[i] \u0026gt; 0) dp[i] += dp[i - dp[i]] 最後就是看整個字串然後一邊用 dp 值更新答案\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int longestValidParentheses(string s) { int n = s.length(), left = 0, ans = 0; vector\u0026lt;int\u0026gt; dp(n, 0); for (int i = 0; i \u0026lt; n; i++) { if (s[i] == \u0026#39;(\u0026#39;) { left++; } else if (left \u0026gt; 0) { dp[i] = dp[i - 1] + 2; dp[i] += (i \u0026gt; dp[i]) ? dp[i - dp[i]] : 0; ans = max(ans, dp[i]); left--; } } return ans; } }; ","permalink":"https://yun-20459.github.io/posts/leetcode-32-longest-valid-parentheses/","tags":["Leetcode","dp"],"title":"Leetcode 32. Longest Valid Parentheses"},{"contents":"Browser default style 每個瀏覽器會有自己的 default style，所以網路上有開源的 .css 讓開發者們用，可以 undo browser default style 然後根據自己的規則在不同的瀏覽器上顯示一樣的東西\n常用的有\nMeyer Reset Normalize CSS 這邊 可以看到瀏覽器的 default style\nAbsolute/Relative Unit Absolute\n像是 px 這種直接給定幾個 pixel 的\nRelative\nem/rem em: 看元素的 font-size，如果元素的 font-size 是 10px，那 2em = 10px * 2 = 20px rem(recommended): 看 :root 或 html 的 font-size viewport Unit vh: 1vh = 1% viewport height vw: 1vw = 1% viewport width viewport unit 可以做的事 font online font library Google Fonts、Font library\n使用\n1 2 3 \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.googleapis.com\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.gstatic.com\u0026#34; crossorigin\u0026gt; \u0026lt;link href=\u0026#34;https://fonts.googleapis.com/css2?family=Roboto\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; 或者\n1 2 /* style.css */ @import url(\u0026#39;https://fonts.googleapis.com/css2?family=Roboto\u0026amp;display=swap\u0026#39;); text styles 如果只是想讓字變斜體用 font-style，文字要斜體又加強重點的話用 \u0026lt;em\u0026gt;\n控制文字橫間距用 letter-spacing: .5em，行間距用 letter-height: 1.5\ntext-transform 可以變內容全部變大/小寫\ntext-shadow 可以幫文字加陰影\nellipsis 可以讓超過範圍的文字隱藏，搭配使用如下\n1 2 3 4 5 .overflowing { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } 其中 overflow 也可以設定成 visible、scroll 之類的\nadvanced selectors Parent and Sibling Combinators \u0026gt;: child combinator +: adjacent sibling combinator ~: general sibling combinator 例子\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;main class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child group1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;grand-child group1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child group2\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;grand-child group2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child group3\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;grand-child group3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/main\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* This rule will only select divs with a class of child */ main \u0026gt; div { /* Our cool CSS */ } /* This rule will only select divs with a class of grand-child */ main \u0026gt; div \u0026gt; div { /* More cool CSS */ } /* This rule will only select the div with the class child group2 */ .group1 + div { /* Our cool CSS */ } /* This rule will only select the div with the class child group3 */ .group1 + div + div { /* More cool CSS */ } /* This rule will select all of .group1\u0026#39;s siblings - in this case the 2nd and 3rd .child divs */ .group1 ~ div { /* Our cool CSS */ } pseudo class/element pseudo class 就是讓特定的 html tag 不用寫 class 來加上 css，為什麼不寫 class 是因為可能想指定的是文章第一段，那文章一直增加 html 就要一直改\n常用的 pseudo class 有\n:root :first-child、:last-child、:only-child、:empty（沒小孩）、:nth-child用法 :invalid :hover、:visited、:focus、:link pseudo element 也是類似的意思，只是它會指的東西是 tag 裡的內容，例如段落的第一行之類的，也可以同時跟 pseudo class 並用\n常用的 pseudo element:\n::before、::after: 可以在裡面設定 content 顯示在元素的前後，或者 content 為空字串放 block 之類的，可以參考 這個例子 ::marker 可以調整 \u0026lt;li\u0026gt; 的 style ::first-letter、::first-line ::selection: 可以讓使用者在用滑鼠選文字的時候出現想要的 css style attribute selectors [attribute]: 選所有有這個 attribute 的 selector[attribute]: 選這些 selector 有 這個 attribute 的 [attribute=\u0026quot;value\u0026quot;]: 選有這個 attribute 且 value 是特定的 例子\n1 2 3 4 5 6 7 8 9 10 11 [src] { /* This will target any element that has a src attribute. */ } img[src] { /* This will only target img elements that have a src attribute. */ } img[src=\u0026#34;puppy.jpg\u0026#34;] { /* This will target img elements with a src attribute that is exactly \u0026#34;puppy.jpg\u0026#34; */ } 搭配 regex 使用的話\n[attribute^=\u0026quot;value\u0026quot;]: value 前綴有 \u0026ldquo;value\u0026rdquo; 的 [attribute$=\u0026quot;value\u0026quot;]: value 後綴有 \u0026ldquo;value\u0026rdquo; 的 [attribute*=\u0026quot;value\u0026quot;]: value 中任何地方有出現 \u0026ldquo;value\u0026rdquo; 的 Positioning static: 會被放在預設的位置 relative: 跟 static 差不多但是可以定義 top, bottom, left, right absolute: 透過定義 top, bottom, left, right 放在螢幕上的固定位置，適用的 case 有 modals image with a caption on it icons on top of other elements fixed: 會直接固定在螢幕上，不管怎麼滑動都會在那裡 ex. 導覽列、聊天按鍵 sticky: 還沒滑到之前跟一般元素一樣，滑經過後會變成 fixed CSS functions calc(): 可以透過 css variable 去算各個區塊的大小 例子 min()、max(): 選最小/大的 例子 clamp(): 要給三個參數，smallest value, ideal value, largest value 其他 custom properties CSS variable declaration: -- 為開頭，用 - 來分開單字 ex.--color-error-text 跟 js 一樣有 scope 的概念，可以繼承，如果是全部都可以用的話可以定義在 :root 實際應用 set themes: :root 可以加上 class，再加上一點 js 就可以轉換 theme 例子 default theme: 可以用 prefers-color-scheme 這個 media query 來看 OS/user agent 的偏好主題來設定 例子 其他 box-shadow: 元素加上陰影 Can I use 可以看 browser 有沒有支援想寫的 css feature 常用的 css framework: Bootstrap、Tailwind 常用的 css preprocessor: SASS、Stylus 可以把 code 轉成 css ","permalink":"https://yun-20459.github.io/posts/frontend-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-more-on-css/","tags":["css"],"title":"frontend 學習筆記 - more on css"},{"contents":"html tag 們可以參考 這裡 table tag 簡單來說就是可以生成表格的 tag\n\u0026lt;tr\u0026gt;: table row，包在這個裡面的會形成一個 row \u0026lt;td\u0026gt;: table data，就是放格子中要填的 data \u0026lt;th\u0026gt;: table header，就是在 table 中的 header \u0026lt;colgroup\u0026gt;、\u0026lt;col\u0026gt;: 前者是拿來放後者的，放幾個就產生幾個 column 例子，他的 live demo\n\u0026lt;caption\u0026gt;: 字面上意思，會出現在表格上面，可以簡短說明表格內容的文字 \u0026lt;thead\u0026gt;、\u0026lt;tfoot\u0026gt;、\u0026lt;tbody\u0026gt;: 讓整個 table 結構化 例子，他的 live demo\nid、header: 可以在 table header 上面加上 id，然後在他的子表格（？）透過這些 id 標明他的 header 有誰 例子，他的 live demo\ncss css cheat sheet emmet 應該算是一種輔助寫 html 的強大 plugin\nemmet cheet sheet\nWrap with Abbreviation 在 vscode 裡的用法是\n選起來要被包住的內容 先 Ctrl + Shift + P 叫出 command palette 輸入 Emmet: Wrap with Abbreviation 然後就可以打指令了 （或者也可以 command+k command+s 打開 keyboard shortcut 設定，如果懶得設定，可以直接去 extension 下載 emmet keybindings 用）\n例如說從\n1 2 3 \u0026lt;div id=\u0026#34;page\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Hello world\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 變成\n1 2 3 4 5 6 7 8 \u0026lt;div id=\u0026#34;page\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Title\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Hello world\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 就是輸入 div.wrapper\u0026gt;h1{Title}+div.content\n這邊 有完整的介紹有哪些好用功能\nRemove tags 這邊 就是講說可以直接拔掉 tag 然後他會幫你調整 indent\nsvg 一種由 XML 構成的向量圖檔，適合簡單的圖用的格式，Adobe Illustrator 跟 Figma 是比較常見用來產 svg 檔的 app，也可以用 code 產生。如果想做資料視覺化的 svg，可以用 這個\n這裡有一個插在 html 中的 例子\n一些有關裡面的 code 的重點：\nxmlns: XML namespace，類似告訴瀏覽器要怎麼解讀這個 xml 檔的命名空間 viewBox: svg 檔的邊界，在 svg 檔裡的元素都是參考這個 class、id: 跟 html 的一樣，可以方便 css 或 js 拿東西（或者 \u0026lt;use\u0026gt; 複製東西） \u0026lt;circle\u0026gt;、rect、path、text: 存在 namespace 的元素，更多可以看 這裡 fill、stroke: 可以用 css 改變的屬性，可以看 這裡 插入 svg inline: 就是把 xml code 直接貼到 html 內 link: 可以用 \u0026lt;img\u0026gt;，或者在 css 中寫 background-image: url(./my-image.svg) svg icon libraries Material icons\nFeather icons\nthe Noun Project\n","permalink":"https://yun-20459.github.io/posts/frontend-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/","tags":["html","css","emmet","svg"],"title":"frontend 學習筆記"},{"contents":"寫在網頁裡的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Page Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // Your JavaScript goes here! console.log(\u0026#34;Hello, World!\u0026#34;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 或者\n1 \u0026lt;script src=\u0026#34;javascript.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Variable 宣告 let 是一般變數，const是常數變數\n用駝峰式命名法（const 的話全部大寫）\n- 不應該出現在命名中，無意義的變數可以用 $ 或者 _\n不要把變數都宣告在同一行\n可以用科學記號賦值\ninteger 精度只到 15 位數\n1 2 let x = 999999999999999; // x will be 999999999999999 let y = 9999999999999999; // y will be 10000000000000000 string method Extract string part slice: 區間是左閉右開\n1 2 3 4 5 let str = \u0026#34;Apple, Banana, Kiwi\u0026#34;; alert(str.slice(7, 13)); // \u0026#34;Banana\u0026#34; alert(str.slice(-12, -6)); // \u0026#34;Banana\u0026#34; alert(str.slice(7)); // \u0026#34;Banana, Kiwi\u0026#34; alert(str.slice(-12)); // \u0026#34;Banana, Kiwi\u0026#34; substring: 跟 slice 很像只是不吃負數\nsubstr: 跟 slice 很像只是第二個參數是長度，不給的話就是剩下全部\nreplace string content replace example code\n1 2 let text = \u0026#34;Please visit Microsoft!\u0026#34;; let newText = text.replace(\u0026#34;Microsoft\u0026#34;, \u0026#34;W3Schools\u0026#34;); 只會 replace 第一個出現的 (可以用正規表達式弄成全部替換)\n1 2 let text = \u0026#34;Please visit Microsoft and Microsoft!\u0026#34;; let newText = text.replace(/Microsoft/g, \u0026#34;W3Schools\u0026#34;); case sensitive (可以用正規表達式弄成 insensitive)\n1 2 let text = \u0026#34;Please visit Microsoft!\u0026#34;; let newText = text.replace(/MICROSOFT/i, \u0026#34;W3Schools\u0026#34;); 會回傳一個新的 string 而不是去改原 string\nConvert to Upper/Lower case toUpperCase()、toLowerCase() Extract string character charAt() 跟 [] 可以直接拿特定位置的字元，charCodeAt() 是拿特定字元的 unicode string 轉 array split: 看要用什麼字串把 string 切開變成 array，如果字串給的是 \u0026quot;\u0026quot;，那就會把每個字元都切開 Others trim() 可以剪掉前後的空白字元\npadStart()、padEnd() 可以在 string 前/後 padding，第一個參數是 padding 過後的總長，第二個參數是要 padding 的字串\n1 2 3 let text = \u0026#34;5\u0026#34;; let padded = text.padStart(4,\u0026#34;0\u0026#34;); // \u0026#34;0005\u0026#34; let padded = text.padEnd(4,\u0026#34;x\u0026#34;); // \u0026#34;5xxx\u0026#34; 運算子 算術運算子 跟 C++ 不一樣的是指數是 ** 剩下都一樣。\n不過加法運算子 + 比較酷，看以下例子可以發現數字 + string 會是 string concatenation，但是有些情況不一樣，我猜應該是看前後型態一不一致，如果不一樣才轉。\n1 2 3 let x = 10; let y = \u0026#34;20\u0026#34;; let z = x + y; // \u0026#34;1020\u0026#34; 1 2 3 4 let x = 10; let y = 20; let z = \u0026#34;The result is: \u0026#34; + x + y; // The result is 1020; 1 2 3 4 let x = 10; let y = 20; let z = \u0026#34;30\u0026#34;; let result = x + y + z; // \u0026#34;3030\u0026#34; 剩下一些酷酷的東西\n可以直接拿 string -/*，要轉成數字 + 的話可以這樣寫\n1 2 3 let string1 = \u0026#34;1\u0026#34;; let string2 = \u0026#34;2\u0026#34;; alert( +string1 + +string2 ); // \u0026#34;3\u0026#34; 可以用 isNaN() 來看一個變數是不是 NaN (NaN: value is not a number)\njs 預設是以十進位 display number，如果要用其他進位可以用 .toString(\u0026lt;base\u0026gt;)\n比較運算子 == 會先把變數轉成同個 type 再比對，=== 是直接比對。\n1 2 3 4 let number2 = 2; let string2 = \u0026#34;2\u0026#34;; alert(number2 == string2); // true alert(number2 === string2); // false 邏輯運算子 \u0026amp;\u0026amp; 如果第一個變數是 truthy，那就會回傳第二個變數；如果是 falsy，就會回傳第一個變數 || 如果遇到一個 truthy 就會回傳，如果全部都是 falsy，就回傳最後一個 語法 switch 跟 C++ 的一樣\narray 宣告\n1 2 3 4 5 6 7 const array = []; array[0] = \u0026#34;hello\u0026#34;; array[1] = \u0026#34;world\u0026#34;; // or const array = [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;]; 取/改值\n1 2 3 4 // access array element let string = array[0]; // change an array element array[0] = \u0026#34;hi\u0026#34;; 網頁存取整個陣列\n1 2 const cars = [\u0026#34;Saab\u0026#34;, \u0026#34;Volvo\u0026#34;, \u0026#34;BMW\u0026#34;]; document.getElementById(\u0026#34;demo\u0026#34;).innerHTML = cars; array element 可以是不同 type (variable, function, array 都可以)\narray v.s. objects\narray 用的是 numbered indexes object 用的是 named indexes 可以用 Array.isArray(\u0026lt;array name\u0026gt;) 來看是不是 array\n常用 method\ntoString()\n1 2 3 const fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;]; document.getElementById(\u0026#34;demo\u0026#34;).innerHTML = fruits.toString(); // Banana,Orange,Apple,Mango .join()\n1 2 3 const fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;]; document.getElementById(\u0026#34;demo\u0026#34;).innerHTML = fruits.join(\u0026#34; * \u0026#34;); // Banana * Orange * Apple * Mango .push()、.pop()\n1 2 3 4 5 6 7 const fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Apple\u0026#34;]; fruits.push(\u0026#34;Lemon\u0026#34;); // or fruits[fruits.length] = \u0026#34;Lemon\u0026#34;; let fruit = fruits.pop(); // Lemon .shift()\n把最前面的 element pop 出來然後把剩下的 element 往前推\n1 2 const fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;]; let fruit = fruits.shift(); // Banana .unshift()\n在最前面加入元素然後把剩下的往後推\n1 2 const fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;]; fruits.unshift(\u0026#34;Lemon\u0026#34;); // return new array length .concat()\nconcatenate 兩個以上的 array\n1 2 3 4 const myGirls = [\u0026#34;Cecilie\u0026#34;, \u0026#34;Lone\u0026#34;]; const myBoys = [\u0026#34;Emil\u0026#34;, \u0026#34;Tobias\u0026#34;, \u0026#34;Linus\u0026#34;]; const myChildren = myGirls.concat(myBoys); .splice()\n在指定位置插入元素。\n第一個參數：插入的 index\n第二個參數：插入之前要先刪掉第一個參數開始（包括）的幾個 element\n後面的參數：要插入的元素\n1 2 const fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;]; fruits.splice(2, 0, \u0026#34;Lemon\u0026#34;, \u0026#34;Kiwi\u0026#34;); .slice()\n跟 str 的 slice 很像，就是把指定的 index（包括）後的所有 array 切下來\n1 2 3 const fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Lemon\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;]; const citrus = fruits.slice(1); const citrus = fruits.slice(1, 3); loop for\n下面有幾種 for 的寫法，其實就跟 C++ 差不多。\n1 2 3 4 5 6 7 8 9 10 11 12 13 for (let i = 0; i \u0026lt; 100; i++) { // do something here } const cats = [\u0026#39;Pete\u0026#39;, \u0026#39;Biggles\u0026#39;, \u0026#39;Jasmine\u0026#39;]; let myFavoriteCats = \u0026#39;My cats are called \u0026#39;; for (const cat of cats) { myFavoriteCats += `${cat}, ` } console.log(myFavoriteCats); // \u0026#34;My cats are called Pete, Biggles, Jasmine, \u0026#34; while、do-while: 跟 C++ 一模一樣\nbreak\njs 的 break 還蠻酷的，簡單說可以想成類似幫 loop 取名，然後就可以透過 loop name 直接 break 出去\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 outer: for (let i = 0; i \u0026lt; 3; i++) { for (let j = 0; j \u0026lt; 3; j++) { let input = prompt(`Value at coords (${i},${j})`, \u0026#39;\u0026#39;); // if an empty string or canceled, then break out of both loops if (!input) break outer; // (*) // do something with the value... } } alert(\u0026#39;Done!\u0026#39;); Function anonymous function 簡單來說就是沒有名字的 function，可以看下面這個例子。\n原始的寫法：\n1 2 3 4 5 function logKey(event) { console.log(`You pressed \u0026#34;${event.key}\u0026#34;.`); } textBox.addEventListener(\u0026#39;keydown\u0026#39;, logKey); 可以發現其實 function 不需要另外 define，所以可以寫成：\n1 2 3 textBox.addEventListener(\u0026#39;keydown\u0026#39;, function(event) { console.log(`You pressed \u0026#34;${event.key}\u0026#34;.`); }); 就變成 pass anonymous function，然後這可以有另一種寫法叫做 arrow function。\n1 2 3 textBox.addEventListener(\u0026#39;keydown\u0026#39;, (event) =\u0026gt; { console.log(`You pressed \u0026#34;${event.key}\u0026#34;.`); }); 其中如果 code 只有一行大括號可以拿掉，參數只有一個可以把小括號拿掉。\n1 textBox.addEventListener(\u0026#39;keydown\u0026#39;, event =\u0026gt; console.log(`You pressed \u0026#34;${event.key}\u0026#34;.`)); function expression 意思是說我可以在任何 expression 的中間 create functions.\n1 2 3 4 5 6 7 8 9 // function expression let sayHi = function() { alert( \u0026#34;Hello\u0026#34; ); }; //function declaration function sayHi() { alert( \u0026#34;Hello\u0026#34; ); } function is a value\n因為 function 是 value，所以我可以 print 他的值出來看。\n1 2 3 4 5 function sayHi() { alert( \u0026#34;Hello\u0026#34; ); } alert( sayHi ); // shows the function code 也可以把他 copy 給其他 variable\n1 2 3 4 5 6 7 function sayHi() { // (1) create alert( \u0026#34;Hello\u0026#34; ); } let func = sayHi; // (2) copy func(); // Hello // (3) run the copy (it works)! block scope\n在 strict mode 裡，只要在 block 裡有做 function declaration，那在 block 裡的任何一個地方用都可以。\narrow functions function 比較簡單簡潔的寫法，在前面 anonymous function 有提到過。\n如果一個 function 原本寫成這樣\n1 2 3 let func = function(arg1, arg2, ..., argN) { return expression; }; 那就可以改成\n1 let func = (arg1, arg2, ..., argN) =\u0026gt; expression; 如果沒有參數的話可以寫成\n1 let sayHi = () =\u0026gt; alert(\u0026#34;Hello!\u0026#34;); Clean code style Indentention 不要混用 line length 不要太長 命名的時候變數以名詞跟形容詞做開頭，function 以動詞做開頭 function 不要寫太大，試著弄成好幾個小 function 比較好維護 + debug comment 不要亂寫，必要的時候拿來解釋 code 在幹嘛 (code tells you how, comment tells you why) Node.js Node.js is a JavaScript runtime environment that allows you to run JavaScript outside of your web browser.\n下載 nvm (node version manager)\n1 curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash 下載 node\n1 nvm install --lts 設定 node 版本\n1 nvm use --lts 使用\n打開 terminal 打\n1 node 就可以用了，如果要關掉就打\n1 .exit DOM (document object model) 把 html 裡的各個標籤都變成物件，然後這些物件會變成樹狀結構的 node。\nselector\n可以取到特定 node 的東西\n假設 html 長這樣\n1 2 3 4 \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;display\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;controls\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 我想要拿到 \u0026lt;div class=\u0026quot;display\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 的話，可以用 div.display、.display、#container \u0026gt; .display、div#container \u0026gt; div.display\n或者用\n1 2 3 4 5 6 7 8 9 10 11 const container = document.querySelector(\u0026#39;#container\u0026#39;); // selects the #container div (don\u0026#39;t worry about the syntax, we\u0026#39;ll get there) console.dir(container.firstElementChild); // selects the first child of #container =\u0026gt; .display const controls = document.querySelector(\u0026#39;.controls\u0026#39;); // selects the .controls div console.dir(controls.previousElementSibling); // selects the prior sibling =\u0026gt; .display querySelector\n如果用 .querySelectorAll() 的話，回傳的會是 nodelist 不是 array！可以用 Array.from() 或者 spread operator 解決 element creation\ndocument.createElement(tagName, [options]) 可以在 DOM memory （不是 page）中建一個 tag type tagName 的 element。\nappend element\n1 2 3 4 parentNode.appendChild(childNode) // appends childNode as the last child of parentNode parentNode.insertBefore(newNode, referenceNode) // inserts newNode into parentNode before referenceNode remove element\n1 2 parentNode.removeChild(child) // removes child from parentNode on the DOM and returns a reference to child altering element\n可以改 element 的屬性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 const div = document.createElement(\u0026#39;div\u0026#39;); // creates a new div referenced in the variable \u0026#39;div\u0026#39; div.style.color = \u0026#39;blue\u0026#39;; // adds the indicated style rule div.style.cssText = \u0026#39;color: blue; background: white;\u0026#39;; // adds several style rules div.setAttribute(\u0026#39;style\u0026#39;, \u0026#39;color: blue; background: white;\u0026#39;); // adds several style rules div.setAttribute(\u0026#39;id\u0026#39;, \u0026#39;theDiv\u0026#39;); // if id exists, update it to \u0026#39;theDiv\u0026#39;, else create an id // with value \u0026#34;theDiv\u0026#34; div.getAttribute(\u0026#39;id\u0026#39;); // returns value of specified attribute, in this case // \u0026#34;theDiv\u0026#34; div.removeAttribute(\u0026#39;id\u0026#39;); // removes specified attribute div.textContent = \u0026#39;Hello World!\u0026#39; // creates a text node containing \u0026#34;Hello World!\u0026#34; and // inserts it in div div.innerHTML = \u0026#39;\u0026lt;span\u0026gt;Hello World!\u0026lt;/span\u0026gt;\u0026#39;; // renders the HTML inside div 要注意的是 css 是 kebab-cased 的話，js 在 assign 屬性要用 camelCase\n1 2 3 4 5 6 7 8 div.style.background-color // doesn\u0026#39;t work - attempts to subtract color from div.style.background div.style.backgroundColor // accesses the div\u0026#39;s background-color style div.style[\u0026#39;background-color\u0026#39;] // also works div.style.cssText = \u0026#34;background-color: white;\u0026#34; // ok in a string working with classes\n1 2 3 4 5 6 7 8 9 div.classList.add(\u0026#39;new\u0026#39;); // adds class \u0026#34;new\u0026#34; to your new div div.classList.remove(\u0026#39;new\u0026#39;); // removes \u0026#34;new\u0026#34; class from div div.classList.toggle(\u0026#39;active\u0026#39;); // if div doesn\u0026#39;t have class \u0026#34;active\u0026#34; then add it, or if // it does, then remove it Event 就是各種會發生在網頁上的事？例如按滑鼠之類的\n可以用下列三種方法建立 event\nmethod 1\n1 2 3 4 \u0026lt;button onclick=\u0026#34;alert(\u0026#39;Hello World\u0026#39;)\u0026#34;\u0026gt;Click Me\u0026lt;/button\u0026gt; // named function method with js \u0026lt;button onclick=\u0026#34;alertFunction()\u0026#34;\u0026gt;Click Me\u0026lt;/button\u0026gt; 1 2 3 function alertFunction() { alert(\u0026#34;YAY! YOU DID IT!\u0026#34;); } method 2\n1 \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;Click Me\u0026lt;/button\u0026gt; 1 2 3 4 5 const btn = document.querySelector(\u0026#39;#btn\u0026#39;); btn.onclick = () =\u0026gt; alert(\u0026#34;Hello World\u0026#34;); // named function method with js above btn.onclick = alertFunction; method 3\n1 \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;Click Me\u0026lt;/button\u0026gt; 1 2 3 4 5 6 7 const btn = document.querySelector(\u0026#39;#btn\u0026#39;); btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { alert(\u0026#34;Hello World\u0026#34;); }); // named function method with js above btn.addEventListener(\u0026#39;click\u0026#39;, alertFunction); 可以用這個來做酷酷的動畫，例如說\n1 2 3 btn.addEventListener(\u0026#39;click\u0026#39;, function (e) { e.target.style.background = \u0026#39;blue\u0026#39;; }); 這段 code 中 e 是指那個觸發的 event， .target 則會拿到被點擊的 DOM node。\n如果要再多個 button 上面加 EventListener 呢？\n1 2 3 4 5 \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;1\u0026#34;\u0026gt;Click Me\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;2\u0026#34;\u0026gt;Click Me\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;3\u0026#34;\u0026gt;Click Me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 // buttons is a node list. It looks and acts much like an array. const buttons = document.querySelectorAll(\u0026#39;button\u0026#39;); // we use the .forEach method to iterate through each button buttons.forEach((button) =\u0026gt; { // and for each one we add a \u0026#39;click\u0026#39; listener button.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { alert(button.id); }); }); ","permalink":"https://yun-20459.github.io/posts/frontend-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-js/","tags":["js"],"title":"frontend 學習筆記 - js"},{"contents":"flexbox 是什麼 應該是個切版好工具？大概的功能是讓 element 可以併排，而不是 stacking 或者 centering。 例子可以看 這裡\n分類 flex container flex item 外容器 在 flex container 中的 item display, flex-flow(direction \u0026amp; wrap), justify-content, align-items flex, order, align-self flex item 也可以同時作為 flex container！ flex container display 可以用 display: flex; 或 display: inline-flex;，後者是類似 inline-block + flex。\nflex-flow axes\n設定 main axis 跟 cross axis，這兩個東西是相對的。 ex. flex-direction: row 就是讓 main axis 是水平的，也就是說會讓 item 水平排列。\ndefault 是 row，如果變成 column 的話，flex-basis 會看 height 而不是 width。\n還可以用 row-reverse 跟 column-reverse，會影響 start end line，詳細可以看這裡 wrap\n可以用 nowrap、wrap、wrap-reverse決定不換行、換行、換行時反轉\nalignment 如果想要排 main axis 上的東西用 justify-content，排 cross axis 上的東西用 align-items。東西太擠的話可以加上 gap。\njustify-content 選項：flex-start、flex-end、center、space-between、space-around align-items 選項：flex-start、flex-end、center、baseline、stretch align-content 選項（多行版本）: flex-start、flex-end、center、space-between、space-around、stretch 可以玩一下這個人的 codepen 理解\nflex item flex flex 裡面分為：flex-grow、flex-shrink、flex-basis default: flex: 0 1 0% flex-grow: 就是看在 container 中要長大成幾倍 flex-shrink: grow 的相反，不過只會在 item 全部總寬大於 container 的時候才會 apply flex-basis: grow 跟 shrink 的 baseline default 是 auto，會去看 item 的 width 是多少 寫 flex: 1 等於 flex: 1 1 0% 寫 flex: auto 等於 flex: 1 1 auto order 可以按照自己需求排列 item，可以看這個例子比較好懂。\nalign-self 調整 cross axis 的對齊設定，可以用 auto、flex-start、flex-end、center、baseline、stretch\n寫法的話直接\n1 2 3 .align-self { align-self: center; } ","permalink":"https://yun-20459.github.io/posts/frontend-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-flexbox/","tags":["css","flexbox"],"title":"frontend 學習筆記 - flexbox"},{"contents":"題目 link\n作法 我是看 hint 才會的 QQ，hint 就是這題其實要反著做，就是說如果 target array 是可以被構造出來的話，逆推回去就應該是對的。\n作法是把最大值一個一個從 priority_queue 中拔出來處理，有三種情況應該要 return false\nval \u0026lt;= sum\n可以假設被修改前值是 $x$，剩下的值總和是 $y$，所以修改後的值是 $x+y$。 從 code 裡可以看到現在 $sum = y$，所以理論上是不會大於 $x + y$ 的。\nsum \u0026lt; 1\n根據 1. 可以發現既然 $sum = y$，那因為要構造的陣列值都是 1 ，所以如果小於 1 就是錯的。\nsum != 1 and val == 0\n這邊牽扯到我上面的一點實作方式，因為同一個值可能被操作很多次，所以可以直接 %=sum 找到操作前的值，再把它加上 $sum$ 就是修改前的陣列總和。那這邊需要特判[1, 1]這個 case，因為雖然理論上val == 0會是錯的（因為這代表修改前的值是 0 \u0026lt; 1），但是可以發現這個 case 在這裡會是錯的，所以需要特判掉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: bool isPossible(vector\u0026lt;int\u0026gt;\u0026amp; target) { priority_queue\u0026lt;int\u0026gt; pq; unsigned int sum = 0; for (int num : target) { pq.push(num); sum += num; } int val = -1; while (pq.top() != 1) { val = pq.top(); pq.pop(); sum -= val; if (val \u0026lt;= sum || sum \u0026lt; 1) return false; val %= sum; sum += val; if (sum != 1 and val == 0) return false; pq.push(val); } return true; } }; ","permalink":"https://yun-20459.github.io/posts/leetcode-1354-construct-target-array-with-multiple-sums/","tags":["Leetcode","priority_queue"],"title":"Leetcode 1354. Construct Target Array With Multiple Sums"},{"contents":"基礎架構 1 2 3 \u0026lt;selector\u0026gt; { \u0026lt;property\u0026gt;: \u0026lt;value\u0026gt;; } selector universal selector\n1 2 3 * { color: purple; } type selector\n1 2 3 div { color: white; } class selector\n1 2 3 \u0026lt;div class=\u0026#34;alert-text severe-alert\u0026#34;\u0026gt; Please agree to our terms of service. \u0026lt;/div\u0026gt; 1 2 3 .alert-text { color: red; } id selector\n1 \u0026lt;div id=\u0026#34;title\u0026#34;\u0026gt;My Awesome 90\u0026#39;s Page\u0026lt;/div\u0026gt; 1 2 3 #title { background-color: red; } difference between class \u0026amp; ID The major difference between classes and IDs is that an element can only have one ID. An ID cannot be repeated on a single page, and the ID attribute should not contain any whitespace at all.\ngrouping selector\n如果有部份宣告一樣的話可以 group 起來一起寫\n1 2 3 4 5 6 7 8 9 10 11 12 13 .read, .unread { color: white; background-color: black; } .read { /* several unique declarations */ } .unread { /* several unique declarations */ } chaining selector\n如果有兩個以上的 class 或者 class + id 的話可以串起來\n1 2 3 4 \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;subsection header\u0026#34;\u0026gt;Latest Posts\u0026lt;/div\u0026gt; \u0026lt;p class=\u0026#34;subsection\u0026#34; id=\u0026#34;preview\u0026#34;\u0026gt;This is where a preview for a post might go.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 1 2 3 4 5 6 7 .subsection.header { color: red; } .subsection#preview { color: blue; } combinator\ndescendant combinator\n.ancestor .child 就是只會選在 class ancestor 裡 class 是 child 的，例如下面的話就是會選到 B 跟 C\n1 2 3 4 5 6 7 8 \u0026lt;div class=\u0026#34;ancestor\u0026#34;\u0026gt; \u0026lt;!-- A --\u0026gt; \u0026lt;div class=\u0026#34;contents\u0026#34;\u0026gt; \u0026lt;!-- B --\u0026gt; \u0026lt;div class=\u0026#34;contents\u0026#34;\u0026gt; \u0026lt;!-- C --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;contents\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- D --\u0026gt; 1 2 3 .ancestor .contents { /* some declarations */ } properties color \u0026amp; background-color\n賦值方法可以看這裡\n1 2 3 4 5 6 7 8 p { /* hex example: */ color: #1100ff; /* rgb example: */ color: rgb(100, 0, 127); /* hsl example: */ color: hsl(15, 82%, 56%); } font \u0026amp; text\nfont-family\nfont family name ex. \u0026ldquo;Times New Roman\u0026rdquo; generic family name ex. sans-serif 可以給 list 讓瀏覽器從第一個去找可以用的 ex. font-family: \u0026quot;Times New Roman\u0026quot;, sans-serif; web safe 的字體可以參考這裡 想用其他開源字體的話這裡 font-size ex. font-size: 22px\nfont-weight: 類似粗體的概念，給數值的話可以從 1~1000\n1 font-weight: bold /*equivalent of font-weight: 700*/ text-align: 各種對齊方法可以看這裡\nimage\n下面的例子是假設原圖是 500(h)x1000(w)，這樣寫的話 height 就會變成 250px\n1 2 3 4 img { height: auto; width: 500px; } cascade of CSS 瀏覽器有可能會有 default style 就會導致自己寫了 css 但是出來跟預期的不一樣\nspecificity\nID selector \u0026gt; class selector \u0026gt; type selector\n1 2 3 4 5 6 7 8 9 10 /* rule 1 */ .subsection { color: blue; } /* rule 2 */ /* this will be chosen */ .main .list { color: red; } 1 2 3 4 5 6 7 8 9 10 11 12 /* rule 1 */ #subsection .list { background-color: yellow; color: blue; } /* rule 2 */ /* this will be chosen */ /* but background will be yellow since there is no conflict declaration for it*/ #subsection .main .list { color: red; } inheritance\n沒講的東西就會繼承，但如果有 selector 單指且跟繼承有衝突的話以 selector 為優先\nrule order\n如果有好幾個 class 且優先度都一樣，會選在 css 裡面最後 defined 的那個\nadding CSS into HTML external css: 寫個 style.css link 進 .html\ninternal css: 在 html 的 head 裡寫\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; div { color: white; background-color: black; } p { color: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;...\u0026lt;/body\u0026gt; box model 所有在 webpage 上的東西都是 rectangle box，然後可以透過 css 調整這個 box 的特性例如\npadding 如果上下一樣 8px ，左右一樣 24px 的話可以寫 padding: 8px 24px; margin 想要 element 靠右可以寫 margin-left: auto; 想要 element 置中可以寫 margin: 0 auto; border block v.s. inline 如果 element 是 block，那就會像一個一個 block 在網頁上按照順序排好，如果是 inline（ex. \u0026lt;a\u0026gt;、\u0026lt;button\u0026gt;），就會直接在放的位置旁邊的 element 的旁邊（繞口令 xD） div \u0026amp; span div 是 block-level 例子 span 是 inline-level 例子 inline-block ","permalink":"https://yun-20459.github.io/posts/frontend-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-css/","tags":["css"],"title":"frontend 學習筆記 - css"},{"contents":"學習網站 link\nhtml \u0026lt;title\u0026gt; \u0026lt;/title\u0026gt; : 網頁標題\n\u0026lt;p\u0026gt; \u0026lt;/p\u0026gt;: 網站內容中的文章 tag\n\u0026lt;h1\u0026gt; \u0026lt;/h1\u0026gt;: 標題字，有 h1~h6\n\u0026lt;strong\u0026gt; \u0026lt;/strong\u0026gt;: 粗體\n\u0026lt;em\u0026gt; \u0026lt;/em\u0026gt;: 斜體\n\u0026lt;!-- comment --\u0026gt;\nlist\nunordered list\n1 2 3 4 5 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ordered list\n1 2 3 4 5 \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 3\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;a href=\u0026quot;url\u0026quot;\u0026gt; \u0026lt;/a\u0026gt;: 超連結\nurl 可以是絕對連結（ex. 外部）or 相對連結（ex. 內部連結）\n1 2 3 4 5 6 \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Homepage\u0026lt;/h1\u0026gt; \u0026lt;a href=\u0026#34;https://www.theodinproject.com/about\u0026#34;\u0026gt;click me\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;./about.html\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;img\u0026gt;: 圖片，一樣可以用絕對連結或相對連結\n1 2 3 4 5 6 \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Homepage\u0026lt;/h1\u0026gt; \u0026lt;img src=\u0026#34;https://www.theodinproject.com/mstile-310x310.png\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;images/dog.jpg\u0026#34; alt=\u0026#34;alternative text\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; others open ./index.html可以直接用 os 預設瀏覽器開啟 index.html replit 是 live coding 的好網站 html validator 可以檢查 html 語法錯誤之類的 ","permalink":"https://yun-20459.github.io/posts/frontend-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-html/","tags":["html"],"title":"frontend 學習筆記 - html"},{"contents":"基礎語法 module\n1 2 3 module \u0026lt;module name\u0026gt;(\u0026lt;parameters\u0026gt;); // module content endmodule assign\n1 assign out = in; gate\nand \u0026amp; or | not ~ xor ^ wire\n1 wire w1, w2, w3; 多進制表示\n\u0026lt;位元長度\u0026gt; ’ \u0026lt;進制表示\u0026gt; \u0026lt;數值資料\u0026gt;\nvector\n1 2 3 4 5 // type [upper:lower] vector_name; output reg [0:0] y; // 1-bit reg that is also an output port (this is still a vector) input wire [3:-2] z; // 6-bit wire input (negative ranges are allowed) output [3:0] a; // 4-bit output wire. Type is \u0026#39;wire\u0026#39; unless specified otherwise. wire [0:7] b; // 8-bit wire where b[0] is the most-significant bit. implicit nets: 永遠都是 one-bit wire\n1 2 3 4 5 6 wire [2:0] a, c; // Two vectors assign a = 3\u0026#39;b101; // a = 101 assign b = a; // b = 1 implicitly-created wire assign c = b; // c = 001 \u0026lt;-- bug my_module i1 (d,e); // d and e are implicitly one-bit wide if not declared. // This could be a bug if the port was intended to be a vector. part-select\n1 2 3 4 5 6 7 w[3:0] // Only the lower 4 bits of w x[1] // The lowest bit of x x[1:1] // ...also the lowest bit of x z[-1:-2] // Two lowest bits of z b[3:0] // Illegal. Vector part-select must match the direction of the declaration. b[0:3] // The *upper* 4 bits of b. assign w[3:0] = b[0:3]; // Assign upper 4 bits of b to lower 4 bits of w. w[3]=b[0], w[2]=b[1], etc. bitwise/logical or\n1 2 3 4 5 6 7 8 9 10 11 module top_module( input [2:0] a, input [2:0] b, output [2:0] out_or_bitwise, output out_or_logical, ); assign out_or_bitwise = a | b; assign out_or_logical = a || b; endmodule concatenation\nexmaple code\n1 2 3 4 5 6 7 8 9 10 input [15:0] in; output [23:0] out; // Swap two bytes. Right side and left side are both 16-bit vectors. assign {out[7:0], out[15:8]} = in; // This is the same thing. assign out[15:0] = {in[7:0], in[15:8]}; // This is different. The 16-bit vector on the right is extended to // match the 24-bit vector on the left, so out[23:16] are zero. // In the first two examples, out[23:16] are not assigned. assign out = {in[7:0], in[15:8]}; 例題\n1 2 3 4 5 6 7 module top_module ( input [4:0] a, b, c, d, e, f, output [7:0] w, x, y, z );// assign {w, x, y, z} = {a, b, c, d, e, f, 2\u0026#39;b11}; endmodule replication operator\n1 2 3 4 5 6 7 8 // {num{vector}} // 5\u0026#39;b11111 (or 5\u0026#39;d31 or 5\u0026#39;h1f) {5{1\u0026#39;b1}} // The same as {a,b,c,a,b,c} {2{a,b,c}} // 9\u0026#39;b101_110_110. It\u0026#39;s a concatenation of 101 with // the second vector, which is two copies of 3\u0026#39;b110. {3\u0026#39;d5, {2{3\u0026#39;d6}}} always\n1 2 3 always@(*)begin end case\nallow duplicate case items case item 有多於一個 statement 的話用 begin end 1 2 3 4 5 case(\u0026lt;case_expr\u0026gt;) condition1: statement1; condition2: statement2; default: default_statement; endcase casez: 可以忽略一些 bit\n1 2 3 4 5 6 7 8 9 always @(*) begin casez (in[3:0]) 4\u0026#39;bzzz1: out = 0; // in[3:1] can be anything 4\u0026#39;bzz1z: out = 1; 4\u0026#39;bz1zz: out = 2; 4\u0026#39;b1zzz: out = 3; // same as 4\u0026#39;b1??? default: out = 0; endcase end always: 一種 procedure\nconbinational: always @(*) clocked: always @(posedge clk) 1 2 3 always @(*) begin // do something here end blocking v.s. non-blocking Continuous assignments (assign x = y;). Can only be used when not inside a procedure (\u0026ldquo;always block\u0026rdquo;). Procedural blocking assignment: (x = y;). Can only be used inside a procedure. Procedural non-blocking assignment: (x \u0026lt;= y;). Can only be used inside a procedure. conditional ternary operator\n就類似像 C 裡面的 conditional ternary operator\n1 2 always @(posedge clk) // A T-flip-flop. q \u0026lt;= toggle ? ~q : q; reduction\n要把所有 bit and/or/xor 起來一個一個寫很麻煩，所以可以直接寫\n1 assign w = ~\u0026amp; a[3:0]; // or ~\u0026amp; a 這樣就是對 a 裡面每個 bit 做 NAND\n酷酷的東西 bit slicing\n可以直接寫\n[M +: N]: 拿從 M 開始正的 offset N 個 bits [M -: N]: 拿從 M 開始負的 offset N 個 bits ","permalink":"https://yun-20459.github.io/posts/verilog-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/","tags":["verilog"],"title":"verilog 學習筆記"},{"contents":"學習範圍 單元 5、單元 6、Jetpack\nSQL 語法 statement\n1 2 3 SELECT name FROM park WHERE type != \u0026#34;recreation_area\u0026#34; AND area_acres \u0026gt; 100000 function\n1 2 3 4 SELECT COUNT(*) FROM park SELECT SUM(park_visitors) FROM park SELECT MAX(area_acres) FROM park SELECT COUNT(DISTINCT type) FROM park ordering \u0026amp; grouping\n1 2 3 4 5 6 7 /* sort by descending order*/ SELECT name FROM park ORDER BY name DESC /* see how many parks of each type are present, and get a separate count for each. */ SELECT type, COUNT(*) FROM park GROUP BY type ORDER BY type inserting \u0026amp; deleting\n1 2 3 4 5 6 7 8 9 10 11 12 INSERT INTO table_name VALUES (column1, column2, ...) UPDATE table_name SET column1 = ..., column2 = ..., ... WHERE column_name = ... ... DELETE FROM table_name WHERE column_name = ... Kotlin 語法 companion object: class 中靜態的成員或方法，可以讓 class 不是整個都靜態的 Android Studio DAO Flow datastore WorkManager Worker WorkRequest WorkManager Jetpack ","permalink":"https://yun-20459.github.io/posts/google-android-study-jam-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-6/","tags":["Andriod","Kotlin","google"],"title":"Google Android Study Jam 學習筆記(6)"},{"contents":"學習範圍 單元 4\nKotlin 語法 thread\nrunBlocking{}、.async() lazy instantiation\n@Json Annotation\nlet\n將最後一行帶到下一個 chain 或是回傳 Scope Function Android Studio debugger ","permalink":"https://yun-20459.github.io/posts/google-android-study-jam-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-5/","tags":["Andriod","Kotlin","google"],"title":"Google Android Study Jam 學習筆記(5)"},{"contents":"學習範圍 單元 3 課程 2~5\nAndroid Studio fragment\n一種可以重複利用的 UI -\nNavigation\nNavHostFragment: container for destinations NavController: conducts navigation NavigationView: menu of drawerlayout NavigationUI: update content outside NavHostFragment Navgraph\napp 中導覽的對應 ex. 從 Home -\u0026gt; Setting 結構準則\nseparation of concerns driving UI from a model main classes / components in Android architecture: UI Controller (activity/fragment), ViewModel, LiveData and Room SlidingPaneLayout\n","permalink":"https://yun-20459.github.io/posts/google-android-study-jam-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-4/","tags":["Andriod","Kotlin","google"],"title":"Google Android Study Jam 學習筆記(4)"},{"contents":"學習範圍 單元 3 課程 1\nKotlin 語法 Set\n1 2 3 val tmp = \u0026lt;list\u0026gt;.toSet() val set1 = setOf(1,2,3) val set2 = mutableSetOf(3,2,1) 可以用 contains()、intersect()、union()\nMap\n1 2 3 4 5 6 7 8 9 10 11 12 fun main() { val peopleAges = mutableMapOf\u0026lt;String, Int\u0026gt;( \u0026#34;Fred\u0026#34; to 30, \u0026#34;Ann\u0026#34; to 23 ) peopleAges.put(\u0026#34;Barbara\u0026#34;, 42) peopleAges[\u0026#34;Joe\u0026#34;] = 51 val filteredNames = peopleAges.filter { it.key.length \u0026lt; 4 } println(peopleAges.map { \u0026#34;${it.key} is ${it.value}\u0026#34; }.joinToString(\u0026#34;, \u0026#34;) ) println(peopleAges) peopleAges.forEach { print(\u0026#34;${it.key} is ${it.value}, \u0026#34;) } } Lambda\n1 2 3 4 5 6 7 8 fun main() { val triple: (Int) -\u0026gt; Int = { a: Int -\u0026gt; a * 3 } println(triple(5)) val peopleNames = listOf(\u0026#34;Fred\u0026#34;, \u0026#34;Ann\u0026#34;, \u0026#34;Barbara\u0026#34;, \u0026#34;Joe\u0026#34;) println(peopleNames.sortedWith { str1: String, str2: String -\u0026gt; str1.length - str2.length }) val words = listOf(\u0026#34;about\u0026#34;, \u0026#34;acute\u0026#34;, \u0026#34;awesome\u0026#34;, \u0026#34;balloon\u0026#34;, \u0026#34;best\u0026#34;, \u0026#34;brief\u0026#34;, \u0026#34;class\u0026#34;, \u0026#34;coffee\u0026#34;, \u0026#34;creative\u0026#34;) val filteredWords = words.filter { it.startsWith(\u0026#34;b\u0026#34;, ignoreCase = true) }.shuffled().take(2) } Android Studio activity life cycle\n","permalink":"https://yun-20459.github.io/posts/google-android-study-jam-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-3/","tags":["Andriod","Kotlin","google"],"title":"Google Android Study Jam 學習筆記(3)"},{"contents":"學習範圍 單元 2 課程 3\nKotlin 語法 list\nlist\n宣告 1 val numbers: List\u0026lt;Int\u0026gt; = listOf(1, 2, 3, 4, 5, 6) 其他 1 2 3 4 5 6 7 8 9 println(\u0026#34;List: $numbers\u0026#34;) // = println(\u0026#34;List: \u0026#34; + numbers) println(\u0026#34;Size: ${numbers.size}\u0026#34;) println(\u0026#34;First element: ${numbers[0]}\u0026#34;) println(\u0026#34;First: ${numbers.first()}\u0026#34;) println(\u0026#34;Last: ${numbers.last()}\u0026#34;) println(\u0026#34;Contains 4? ${numbers.contains(4)}\u0026#34;) // true println(\u0026#34;Contains 7? ${numbers.contains(7)}\u0026#34;) // false println(\u0026#34;Reversed list: ${colors.reversed()}\u0026#34;) println(\u0026#34;Sorted list: ${colors.sorted()}\u0026#34;) mutablelist\n宣告 1 val entrees = mutableListOf\u0026lt;String\u0026gt;() // val entrees: MutableList\u0026lt;String\u0026gt; = mutableListOf() 其他 1 2 3 4 5 6 7 println(\u0026#34;Add noodles: ${entrees.add(\u0026#34;noodles\u0026#34;)}\u0026#34;) val moreItems = listOf(\u0026#34;ravioli\u0026#34;, \u0026#34;lasagna\u0026#34;, \u0026#34;fettuccine\u0026#34;) println(\u0026#34;Add list: ${entrees.addAll(moreItems)}\u0026#34;) // \u0026#34;Add list: true\u0026#34; println(\u0026#34;Remove spaghetti: ${entrees.remove(\u0026#34;spaghetti\u0026#34;)}\u0026#34;) println(\u0026#34;Remove first element: ${entrees.removeAt(0)}\u0026#34;) entrees.clear() println(\u0026#34;Empty? ${entrees.isEmpty()}\u0026#34;) while\n1 2 3 4 5 6 7 8 val guestsPerFamily = listOf(2, 4, 1, 3) var totalGuests = 0 var index = 0 while (index \u0026lt; guestsPerFamily.size) { totalGuests += guestsPerFamily[index] index++ } println(\u0026#34;Total Guest Count: $totalGuests\u0026#34;) for\n1 2 3 for (name in names) println(name) for (item in 5 downTo 1) print(item) for (item in 3..6 step 2) print(item) vararg\n將類型相同、數量可變的引數傳遞給函式或建構函式\n1 2 // 只能將一個參數標示為 vararg，且通常是清單中的最後一個參數。 class Vegetables(vararg val toppings: String) : Item(\u0026#34;Vegetables\u0026#34;, 5) { Android Studio RecycleView\nMaterialCardView\n其他 front end roadmap ","permalink":"https://yun-20459.github.io/posts/google-android-study-jam-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-2/","tags":["Andriod","Kotlin","google"],"title":"Google Android Study Jam 學習筆記(2)"},{"contents":"學習範圍 單元 1 ~ 單元 2 課程 2\nKotlin 語法 函式\n1 2 3 fun \u0026lt;function name\u0026gt; : \u0026lt;return type\u0026gt; { } 輸出\n1 2 println(\u0026#34;Hi\u0026#34;) // 有換行 print(\u0026#34;Hi\u0026#34;) // 沒換行 宣告變數\n1 2 val \u0026lt;variable name\u0026gt; = \u0026lt;variable value\u0026gt; val \u0026lt;variable name\u0026gt; = \u0026lt;class name\u0026gt;(parameter) 迴圈\n1 2 3 repeat (\u0026lt;times\u0026gt;) { } class\n1 2 3 4 5 6 class \u0026lt;class name\u0026gt; (val \u0026lt;variable name\u0026gt;: \u0026lt;variable type\u0026gt;, ...) { val \u0026lt;variable name\u0026gt; = \u0026lt;variable type\u0026gt; fun \u0026lt;function name\u0026gt; { } } inherit\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // abstract: 未完整實作，無法執行個體化 abstract class Dwelling(private var residents: Int) { abstract val buildingMaterial: String abstract val capacity: Int abstract fun floorArea(): Double fun hasRoom(): Boolean { return residents \u0026lt; capacity } fun getRoom() { if (capacity \u0026gt; residents) { residents++ println(\u0026#34;You got a room!\u0026#34;) } else { println(\u0026#34;Sorry, at capacity and no rooms left.\u0026#34;) } } } class SquareCabin( residents: Int, val length: Double) : Dwelling(residents) { override val buildingMaterial = \u0026#34;Wood\u0026#34; override val capacity = 6 override fun floorArea(): Double { return length * length } } // 只有 open 跟 abstract 可以被繼承 open class RoundHut( val residents: Int, val radius: Double) : Dwelling(residents) { override val buildingMaterial = \u0026#34;Straw\u0026#34; override val capacity = 4 override fun floorArea(): Double { return PI * radius * radius } fun calculateMaxCarpetSize(): Double { val diameter = 2 * radius return sqrt(diameter * diameter / 2) } } class RoundTower( residents: Int, radius: Double, val floors: Int = 2) : RoundHut(residents, radius) { override val buildingMaterial = \u0026#34;Stone\u0026#34; override val capacity = floors * 4 override fun floorArea(): Double { return super.floorArea() * floors } } IntRange\n1 val tmp = 1..6 // tmp 是一個 type IntRange 的 variable, 範圍是 [1, 6] when\n1 2 3 when (\u0026lt;variable\u0026gt;) { \u0026lt;value\u0026gt; -\u0026gt; \u0026lt;execute content\u0026gt; } 其中 \u0026lt;value\u0026gt;可以是給定 variable\nwith\n1 2 3 with (instanceName) { // all operations to do with instanceName } 搭配class的例子\n1 2 3 4 5 6 with(squareCabin) { println(\u0026#34;\\nSquare Cabin\\n============\u0026#34;) println(\u0026#34;Capacity: ${capacity}\u0026#34;) println(\u0026#34;Material: ${buildingMaterial}\u0026#34;) println(\u0026#34;Has room? ${hasRoom()}\u0026#34;) } Android Studio UI\nTextView、ImageView、Button material design tool1 material design tool2 component hardcode\n不要 hardcode，把 text 的名稱弄到 string.xml\nex.\n1 2 3 4 \u0026lt;resources\u0026gt; \u0026lt;string name=\u0026#34;app_name\u0026#34;\u0026gt;Happy Birthday\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;happy_birthday_text\u0026#34;\u0026gt;Happy Birthday, Sam!\u0026lt;/string\u0026gt; \u0026lt;/resources\u0026gt; text 那格就變成填 @string/happy_birthday_text\nobject reference (其實我不知道應該把它歸在寫 app 還是語法)\n1 2 3 val rollButton: Button = findViewById(R.id.button) val resultTextView: TextView = findViewById(R.id.textView) resultTextView.text = \u0026#34;6\u0026#34; findViewById會在 layout 中找到 Button，然後把Button的 object reference 存到 rollButton 裡\n顯示訊息給使用者\n1 2 val toast = Toast.makeText(this, \u0026#34;Dice Rolled!\u0026#34;, Toast.LENGTH_SHORT) toast.show() 設定貨幣（數字）規格\n1 val formattedTip = NumberFormat.getCurrencyInstance().format(tip) binding\nactivitity_main.xml 中\n1 binding.tipResult.text = getString(R.string.tip_amount, formattedTip) string.xml 中\n1 \u0026lt;string name=\u0026#34;tip_amount\u0026#34;\u0026gt;Tip Amount: %s\u0026lt;/string\u0026gt; 打完字收起小鍵盤\n1 2 3 4 5 6 7 8 9 10 private fun handleKeyEvent(view: View, keyCode: Int): Boolean { if (keyCode == KeyEvent.KEYCODE_ENTER) { // Hide the keyboard val inputMethodManager = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager inputMethodManager.hideSoftInputFromWindow(view.windowToken, 0) return true } return false } 螢幕轉向、不同尺寸\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;ScrollView xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:padding=\u0026#34;16dp\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; ... \u0026lt;/ConstraintLayout\u0026gt; \u0026lt;/ScrollView\u0026gt; unittest\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @RunWith(AndroidJUnit4::class) class CalculatorTests { @get:Rule() val activity = ActivityScenarioRule(MainActivity::class.java) @Test fun calculate_20_percent_tip() { onView(withId(R.id.cost_of_service_edit_text)) .perform(typeText(\u0026#34;50.00\u0026#34;)) onView(withId(R.id.calculate_button)).perform(click()) onView(withId(R.id.tip_result)) .check(matches(withText(containsString(\u0026#34;$10.00\u0026#34;)))) } } ","permalink":"https://yun-20459.github.io/posts/google-andriod-study-jam-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-1/","tags":["Andriod","Kotlin","google"],"title":"Google Andriod Study Jam 學習筆記(1)"},{"contents":"修的課程 資訊系必修：作業系統、資料結構與演算法\n資訊系選修：多媒體安全、離散數學\n通識：醫學與生活\n已經爆掉的一般選修：機器學習\n作業系統 開課教授：施吉昇、林忠緯\n涼度：-$\\infty$/5\n甜度：3/5 （作業好好做沒意外應該可以保底 A- 之類的）\n又硬又硬的必修系統課 QQ，code 跟作業 pdf 在這裡。\n有人說林上的比較好不過因為我是施班就乾脆聽施的（兩個老師的都可以聽），老師講得很不錯，就算我停修 sp 也是能夠大致聽懂，而且在影片下留言問問題老師也回蠻快的，小缺點就是音質不是很好，身為耳機黨的我常常直接去世（Ｘ，然後老師給的是 .pdf 不是 .key 所以有些精美的動畫會沒辦法抄筆記QQ\n來分享（？）一下我 mp2 發生的蠢事，一開始因為一個 level 忘記 +1 就整個格式爆掉直接 0 分\u0026hellip; 但助教很好心的讓我 regrade，結果 regrade 完 6 分 ==? 結果是我在根本不用輸出東西的地方輸出氣死，還忘記上一個 flag，70 分就這樣說掰掰 QQ，提醒有看到這裡的人記得用 diff 檢查作業，不要跟我一樣因為助教輸出格式很機車就偷懶 QQ 而且這門課作業成績很重，真的不要跟我一樣智障：）\n資料結構與演算法 開課教授：林軒田、蔡欣穆\n涼度：3/5\n甜度：2/5 (2 顆星是給快不及格的人的，請見下面鬼切·等第線)\naka DSA，code 跟 pdf 一樣在這裡。\n這門課我只有後半學期有在上課（Ｘ）因為欣穆老師會直播互動，所以要跟課回答題目，然後會有大地遊戲，蠻好玩的。軒田老師是直播課會有錄影，欣穆老師是翻轉課堂然後會有 with-video quiz 要做，都是上課教過的東西所以不會太難。\n就是跟 ADA 一樣難的是作業不是上課的課（Ｏ），難的點應該是只能用 C 寫不能用 C++ 的 STL 所以要手刻一些資料結構很痛苦 QQ，至於算法的部分 hw3 hw4 都分別有一題難題，我都是被老師們教會的 \u0026gt;\u0026lt; 不過 DSA 出現 treap + 吉如一 是不是搞錯了什麼 QQ (btw 我 hw4 p3 根本毒瘤，可以離線做結果我在線用持久化並查集www)\n等第 分數居間 A+ [94.5, 100] A [87, 94.5) A- [80, 87) B+ [76.5, 80) B [73, 76.5) B- [68, 73) C+ [63, 68) C [58, 63) C- [50, 58) F [0, 50) 多媒體安全 開課教授：吳家麟\n涼度：3/5（扣在期末報告上）\n甜度：5/5\n可以學到很多不在課表上（Ｏ）的安全問題，一開始老師就有說可能會按照我們的需求更改課表所以還算合理？就是老師最後講的一些都是有同學期中報告做的（吧）講的東西都還算有趣，這學期因為改線上所以後來都用 meet 直播然後錄影。\n這門課最累的應該是佔分 60% 的期末報告，期中報告說實在話還可以，不過期末的時候老師希望我們自己 reproduce code 而且要提出自己的想法，真的頗像一般研究所的課，我好爛 QQ 還好有學長可以稍微討論一下大概的形式，不然我真的啥都不會\u0026hellip; 不過 reproduce code 蠻有趣的，會觀察到一些論文中沒（爛）講（掉）的現象\n離散數學 開課教授：呂育道\n涼度：3/5\n甜度：5/5\n筆記\n考題的部分在 NTU-Exam 版上\n開學的時候因為沒選到櫻花班又想說我蠻喜歡數學的，選到扎實一點的班也不錯，我現在很後悔\u0026hellip; 雖然老師的講義很棒很清楚，證明很有邏輯，但越到後面越覺得怎麼跟櫻花班差這麼多\u0026hellip;我真的好累 QAQ\n考試就是證明證明證明，計算題跟量都很少，不過要寫完還是需要思考一下，因為不是所有證明上課都講過，有一些有一點小轉換。\n整體來說我覺得這還是一門很棒的課，只是可能我這學期太忙了最後的一些證明沒有時間好好自己證就直接用硬背的，蠻可惜的。\n醫學與生活 開課教授：合授（楊班）\n涼度：4/5\n甜度：5/5\n通識好課，會介紹很多有用的醫學小常識，不過大部分的醫生都把我們當醫學系在教，ppt 整個看不懂 OwO 不過認真聽還是會有一點小收穫的，例如說物理治療師的那堂課就有教怎麼放鬆肌肉。\n機器學習 開課教授：李宏毅\n涼度：3/5\n甜度：5/5\n傳說中大金的課，因為我有很多老師，所以前 10 份作業做完就順利 A+ 了～ 不過因為我想拿 T-shirt，所以現在還在努力趕工 hw12 中 \u0026gt;\u0026lt;\n雖然很多人宣傳大金了，但還是再說一次，老師的課簡單清楚好懂，又有實作的好課不推嗎 \u0026gt;\u0026lt;\n感想區（Ｘ） 這學期就是一直在寫作業，真的好累 QwQ 尤其後面因為 OS mp2 的成績整個心態炸裂根本沒辦法念書 QQ 不過整學期下來還是收穫很多的，下學期希望可以當上助教，然後好好修課不要把自己累死！\n","permalink":"https://yun-20459.github.io/posts/110-2-%E4%BF%AE%E8%AA%B2%E5%BF%83%E5%BE%97/","tags":["class"],"title":"110-2 修課心得"},{"contents":"我一直以為我會找環欸，結果其實是我會找但要印出來就不會，我就笨 :p\n題目 link\n找圖中隨便一個環然後印路徑，如果沒有就輸出 IMPOSSIBLE。\n作法 就是 dfs 一下(?)，最近在試著改掉開全域的壞習慣 :p，主要是我想要怎麼記祖先想很久，覺得開 parent 陣列又太肥，後來想到當參數傳下去不就好了嗎，笨笨的 :p\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026lt;bits/stdc++.h\u0026gt; #define AC \\ ios::sync_with_stdio(0); \\ cin.tie(0); \\ cout.tie(0); using namespace std; #define DEBUG void dfs(int id, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;adj, vector\u0026lt;bool\u0026gt; \u0026amp;vis, vector\u0026lt;int\u0026gt; \u0026amp;path, int parent) { vis[id] = true; path.push_back(id); for (int nei : adj[id]) { if (nei == parent) { continue; } if (vis[nei]) { path.push_back(nei); int sz = path.size(), pos = -1; for (int i = 0; i \u0026lt; sz - 1; i++) { if (path[i] == nei) { pos = i; break; } } cout \u0026lt;\u0026lt; sz - pos \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; for (int i = pos; i \u0026lt; sz; i++) { cout \u0026lt;\u0026lt; path[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } exit(0); } dfs(nei, adj, vis, path, id); } path.pop_back(); } int main() { AC; int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; adj(n + 1, vector\u0026lt;int\u0026gt;()); vector\u0026lt;bool\u0026gt; vis(n + 1, 0); for (int i = 0; i \u0026lt; m; i++) { int s, e; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e; adj[s].push_back(e); adj[e].push_back(s); } for (int i = 1; i \u0026lt;= n; i++) { if (!vis[i]) { vector\u0026lt;int\u0026gt; path; dfs(i, adj, vis, path, 0); } } cout \u0026lt;\u0026lt; \u0026#34;IMPOSSIBLE\\n\u0026#34;; return 0; } ","permalink":"https://yun-20459.github.io/posts/cses-round-trip/","tags":["CSES","graph"],"title":"CSES Round Trip"},{"contents":"忘記數學了所以來複習一下 :p\n題目 link\n作法 如果假設有 $n$ 個節點的二元樹有 $G_n$ 個，其中以 $i$ 節點為根的數目有 $F_i$ 個，那麼\n$$ G_n = F_1 + F_2 + \u0026hellip; + F_n$$\n根據二元樹的定義，根節點一定大於左節點小於右節點，所以以 $i$ 節點為根的二元樹可以看成是 由 $1$ 到 $i - 1$ 構成的左子樹 加上 由 $i + 1$ 到 $n$ 構成的右子樹，也就是說\n$$F_i = G_{i - 1} * G_{n - i}$$\n所以遞迴式就跑出來了\n$$G_n = G_0 * G_{n - 1} + G_1 * G_{n - 2} + \u0026hellip; + G_{n - 1} * G_0$$\n然後這個東西就是酷酷的卡塔蘭數列~ 因為有公式所以可以預處理然後 $O(1)$，但我還是喜歡這樣寫~\nbtw 公式是 $C_n = \\frac{1}{n + 1} C^{2n}_n$，期中後面的 C 就是高中排列組合學的那個 C\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int numTrees(int n) { vector\u0026lt;int\u0026gt; dp(n + 1, 0); dp[0] = 1; dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt; i; j++) { dp[i] += (dp[j] * dp[i - j - 1]); } } return dp[n]; } }; ","permalink":"https://yun-20459.github.io/posts/leetcode-96-unique-binary-search-trees/","tags":["Leetcode","dp","math"],"title":"Leetcode 96. Unique Binary Search Trees"},{"contents":"寒假因為很無聊就來刷題，絕對不是因為我很廢 :p\n題目 link\n作法 我是先想到 $O(n^2)$ 的做法，對於每個位置 $i$ 都去看前面的位置 $j$ 能不能走得更遠，如果可以的話就把 $i$ 的最小步數更新成走到 $j$ 的步數 +1（從 $j$ 到 $i$）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int jump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; dp(n, INT_MAX); dp[0] = 0; for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { if (j + nums[j] \u0026gt;= i and dp[j] != INT_MAX) { dp[i] = min(dp[i], dp[j] + 1); } } } return dp[n - 1]; } }; 然後這題其實可以 $O(n)$，概念是一樣的，每個位置都去看可以走到多遠，如果走到前一次算出來最遠的地方，就更新成現在算出來可以到達最遠的地方，在到達之前就一直更新，就不用每次都回去重複算到底怎麼走最快。\n比較好的解釋方式可能是如果我可以從 A 點走到 B 點，那麼我當然可以從 A 點走到介在 A、B 點中間的 C 點，那麼如果 C 點可以讓我走到更遠，jumps++就可以想成是原本想要走到 B 點，改成走到 C 點再繼續走。\ncode 我好懶得打，借別人的（Ｘ\n然後這邊 for loop 寫 i \u0026lt; n - 1 是因為實作的關係，這個實作方式如果寫 i \u0026lt; n 的話，[2, 2, 1, 1, 4] 這種 case 會多算一步，而且這種實作方式最後一個可以跳多遠根本不重要，因為他是要求到達最後一個 index。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int jump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int jumps = 0, curr = 0, farthest = 0, n = nums.size(); for (int i = 0; i \u0026lt; n - 1; i++) { farthest = max(farthest, i + nums[i]); if (i == curr) { curr = farthest, jumps++; } } return jumps; } }; 提供另一種實作方法，就是走過去才算跳的步數。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int jump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int jumps = 0, curr = 0, farthest = 0, n = nums.size(); for (int i = 0; i \u0026lt; n; i++) { if (i \u0026gt; curr) { jumps++; curr = fathest; } farthest = max(farthest, i + nums[i]); } return jumps; } }; ","permalink":"https://yun-20459.github.io/posts/leetcode-45-jump-game-ii/","tags":["Leetcode","dp"],"title":"Leetcode 45. Jump Game II"},{"contents":"修的課程 資訊系必修：計算機程式設計、演算法設計與分析、線性代數\n資訊系選修：計算機概論\n通識：現代生物學之應用\n學程必修：神經生物與認知科學專題討論一、普通心理學\n計算機程式設計 開課教授：張傑帆\n涼度：5/5\n甜度：5/5\n以前都只有 P 教授的課，今年突然多了一班僅限大二以上修習 aka 學長姐重修班，選不到 P 教授的課我就很理所當然地跑去當了真強者，不過這邊真強者的程度應該是沒辦法跟 P 教授那邊比，我這種雜魚都能當= =\n當真強者雖然不用考試但一個學期要出六題題目，還蠻累但蠻有趣的，可以練習用py生測資，不過小傷心的是我有一題原本被選當期中考，但考前一小時突然被拔掉了 QAQ，不過沒選我的可能比較好，我後來被選到一題小考班平均只有 14 分我快嚇死以為測資有錯，還好沒有。\n因為當真強者可以直接 A+，所以我不知道是怎麼配分的，學期中好像也調過一兩次，所以就不附了。\n演算法設計與分析 開課教授：陳縕儂、蕭旭君\n涼度：0/5\n甜度：4/5 (今年 84 分以上 A+，殘念 QQ）\naka ADA，目前修過最硬的課沒有之一，第一次作業出來我就覺得我完蛋了，我這學期基本上沒有一天是不碰 ADA 的 QQ，要嘛在研究手寫要嘛在想程式，不過後來遇到了很多熱心的老師，所以後面作業就都快樂的滿分了～\nVivian 跟旭君的課我覺得都適合直播完放 2 倍速聽，Vivian 的有時可以 4 倍速（Ｘ Vivian 的會容易想睡覺，但是老師講的真的很清楚，旭君的語調比較不容易睡著，也是一樣講得很清楚\n這學期最值得誇讚的應該是 TAs，除了少數 TA 真的超雷，多數 TA 都超級有耐心和專業，我覺得修這堂課大概就是三種人，一種是狂跑 TA hour，一種是找好大腿（後半學期的我），一種是我就爛（前半學期的我）。尤其這大概是我第一堂正式練習數學證明的課，第一份作業用 latex 沒有很適應，後來就覺得沒有 latex 不行，很多想講清楚的東西還是用 latex 可以畫得更清楚，當然也有強者用 markdown，我真的不行\u0026hellip;\n作業跟考試題目答案有的都放在 這裡，雖然我開 public 但還是請各位不要隨便張揚\u0026gt;\u0026lt;\n線性代數 開課教授：陳文進\n涼度：4/5\n甜度：4/5 （因為我只拿 A ㄎㄎ\n我甚至完全忘記有這科存在\u0026hellip;作業每週都有而且是小題很多的六題，幾乎都證明但考試幾乎都計算，很容易計算錯的要小心，我個人很容易聽到睡著所以我後來都根據老師給的作業範圍自己唸課本，老師的講義也寫得還不錯，蠻適合當複習用的\n計算機概論 開課教授：徐宏民\n涼度：3/5\n甜度：3/5 (成績出來我再更新）（老師可能最後又調了一點分數，但應該不超過 5 分）\n我以為又涼又甜，實際上因為我太廢了所以不甜，老師會介紹非常多以後必修可能會遇到的知識，例如 OS、Network 之類的，也有教 Git 跟 Python，不過我看以前評價有三人 py 爬蟲專案，今年不知道為什麼沒有有點小可惜，我其實是為了這個選這班的 QQ 上到後來總覺得計概應該要修完所有必修再來修才對 XD 一開始就修會有一點點一知半解的感覺\n作業基本上翻講義就可以寫了，助教也不會刁難，但考試前要念熟講義＋作業，老師很常直接出作業題，有背有分（？）\n現代生物學之應用 開課教授：朱家瑩\n涼度：5/5\n甜度：5/5\n蠻好玩的通識課，有小組報告然後這是我上大學少數幾次遇到不雷甚至很讚的組員，基本上就是講一堆生物相關的東西，有比較簡單的仿生學跟難一點的基因技術，對於生物完全沒學好的我來說還是可以聽得懂＋聽得很開心。小組報告我們組做仿生學相關的桌遊，美工組真的很厲害，還好我只要負責出一張嘴（Ｘ\n神經生物與認知科學專題討論一 開課教授：賴文崧\n涼度：4/5 （它後來要實體到課扣一顆\n甜度：5/5\n這學期最討厭的課 = =，我受傷了無法去上課在家裡跟直播，明明也有提早講，教授卻說不算我出席扣我總成績 6 分，他說可以給醫生證明我就問他說那我給他會還我分數嗎，他就不理我了 = =\n我原本是想修完學程的但是下學期居然還要再修一次這門課 QQ，可能考慮不修完學程了\n普通心理學 開課教授：何文澤\n涼度：2/5\n甜度：5/5\n能修到澤澤的普心真是三生有幸（？）不知道老師什麼時候還會回來台大教，學習調整制度真的很棒，有強迫症識字困難的我可以延長 15 mins 考試真是太好了\u0026hellip; 雖然我期中還是沒寫完 :p 然後老師給我的期末報告分數真的嚇歪我，依照老師給的標準來看我覺得我應該只有 70 卻拿到 92\u0026hellip;\n如果想看完整的評論 這邊請，我好懶得再打一次 :p\n如果想要看我的報告的話 這裡\n感想區（Ｘ） 這學期一開始真的好累，停修 SP 後就好很多，稍嫌可惜的是我覺得我這一學期心態一直很崩，沒有好好念書，甚至打到這邊才想起來少打線代\u0026hellip;但我 ADA 還是修的很開心～\n","permalink":"https://yun-20459.github.io/posts/110-1-%E4%BF%AE%E8%AA%B2%E5%BF%83%E5%BE%97/","tags":["class"],"title":"110-1 修課心得"},{"contents":"general SWE @ Google TW\n112CS b09\n喜歡看設計、心理學、寫扣、嘗試不會的東西\nDiscord: 866534345651912715\n程式相關經驗 CPE 7/7 全國第一\nICPC 靠隊友拿牌\n沒有什麼大專案經驗，都是自己開發好玩的\n發過一篇第 n 作的 paper\n","permalink":"https://yun-20459.github.io/about/","tags":null,"title":"About"},{"contents":"This is the search page, type keywords to search among my articles.\n","permalink":"https://yun-20459.github.io/search/","tags":null,"title":"Search"}]